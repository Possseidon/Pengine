unit OpenGLContext;

interface

// TODO: Application.On(De)Activate disable and reenable fullscreen and trigger some function to handle it ingame maybe

uses
  dglOpenGL, Forms, SysUtils, Controls, Windows, Classes, GLEnums, Color, InputHandler, TimeManager;

type

  { TOpenGLContext }

  TFunction = procedure of object;

  TOpenGLContext = class
  private
    FFullscreen: Boolean;
    FMustUpdateFPS: Boolean;
    FVSync: Boolean;
    FForm: TForm;

    FInput: TInputHandler;
    FTimer: TDeltaTimer;

    FClearMask: TGLAttribMask;
    FClearColor: TColorRGBA;

    FDC: HDC;
    FRC: HGLRC;

    FUpdateFunction, FRenderFunction: TFunction;

    FOldResize: TNotifyEvent;

    FOldWindowState: TWindowState;

    procedure DeactivateHandler(Sender: TObject);
    function GetDeltaTime: Single;
    function GetFPS: Single;
    function GetSeconds: Single;
    procedure Init;

    procedure InitGL;
    procedure FinalizeGL;
    procedure SetClearColor(AValue: TColorRGBA);
    procedure SetFullscreen(AValue: Boolean);
    procedure SetVSync(AValue: Boolean);

    procedure IdleHandler(Sender: TObject; var Done: Boolean);
    procedure Resize(Sender: TObject);
  public
    constructor Create(AUpdateFunc, ARenderFunc: TFunction; AForm: TForm);
    destructor Destroy; override;

    property VSync: Boolean read FVSync write SetVSync;
    property Fullscreen: Boolean read FFullscreen write SetFullscreen;

    property ClearMask: TGLAttribMask read FClearMask write FClearMask;
    property ClearColor: TColorRGBA read FClearColor write SetClearColor;

    property Input: TInputHandler read FInput;

    property DeltaTime: Single read GetDeltaTime;
    property FPS: Single read GetFPS;
    property Seconds: Single read GetSeconds;
    property MustUpdateFPS: Boolean read FMustUpdateFPS;

    procedure Start;
  end;


implementation

{ TOpenGLContext }

procedure TOpenGLContext.Init;
begin
  InitGL;

  FInput := TInputHandler.Create(FForm);
  FTimer.Init;

  ClearMask := amNone;
  ClearColor := ConstColor[ccNone];

  VSync := False;
  FFullscreen := False;

  wglSwapIntervalEXT(Integer(FVSync));
end;

function TOpenGLContext.GetDeltaTime: Single;
begin
  Result := FTimer.DeltaTime;
end;

procedure TOpenGLContext.DeactivateHandler(Sender: TObject);
begin
  FInput.ReleaseAll;
end;

function TOpenGLContext.GetFPS: Single;
begin
  Result := FTimer.FPS;
end;

function TOpenGLContext.GetSeconds: Single;
begin
  Result := FTimer.Seconds;
end;

procedure TOpenGLContext.InitGL;
begin
  FDC := GetDC(FForm.Handle);
  FRC := CreateRenderingContextVersion(FDC, [opDoubleBuffered], 4, 2, True, 32, 24, 0, 0, 0, 0);
  ActivateRenderingContext(FDC, FRC);

  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
end;

procedure TOpenGLContext.Start;
begin
  FOldResize := FForm.OnResize;
  FForm.OnResize := Resize;

  Application.OnDeactivate := DeactivateHandler;
  Application.OnIdle := IdleHandler;
end;

procedure TOpenGLContext.FinalizeGL;
begin
  DeactivateRenderingContext;
  DestroyRenderingContext(FRC);
  ReleaseDC(FForm.Handle, FDC);
end;

procedure TOpenGLContext.SetClearColor(AValue: TColorRGBA);
begin
  if FClearColor = AValue then
    Exit;
  FClearColor := AValue;
  glClearColor(AValue.R, AValue.G, AValue.B, AValue.A);
end;

procedure TOpenGLContext.SetFullscreen(AValue: Boolean);

var
  Flags: LONG;
begin
  if FFullscreen = AValue then
    Exit;
  FFullscreen := AValue;

  if FFullscreen then
  begin
    // activate fullscreen
    {$IFDEF FPC}
      FForm.FormStyle := fsSystemStayOnTop;
    {$ELSE}
      FForm.FormStyle := fsStayOnTop;
    {$ENDIF}
    Flags := GetWindowLong(FForm.Handle, GWL_STYLE);
    Flags := Flags
      and not WS_BORDER
      and not WS_CAPTION
      and not WS_THICKFRAME;
    SetWindowLong(FForm.Handle, GWL_STYLE, Flags);
    FOldWindowState := FForm.WindowState;
    FForm.WindowState := wsNormal;
    FForm.WindowState := wsMaximized;
  end
  else
  begin
    // deactivate fullscreen
    FForm.FormStyle := fsNormal;
    Flags := GetWindowLong(FForm.Handle, GWL_STYLE);
    Flags := Flags
      or WS_BORDER
      or WS_CAPTION
      or WS_THICKFRAME;
    SetWindowLong(FForm.Handle, GWL_STYLE, Flags);
    FForm.WindowState := wsNormal;
    FForm.WindowState := FOldWindowState;
  end;

end;

procedure TOpenGLContext.SetVSync(AValue: Boolean);
begin
  if FVSync = AValue then
    Exit;
  FVSync := AValue;
  wglSwapIntervalEXT(Integer(FVSync));
end;

procedure TOpenGLContext.IdleHandler(Sender: TObject; var Done: Boolean);
begin
  FMustUpdateFPS := FTimer.Update;
  if Assigned(FUpdateFunction) then
    FUpdateFunction;

  glClear(Ord(FClearMask));
  if Assigned(FRenderFunction) then
    FRenderFunction;
  SwapBuffers(FDC);

  Input.NotifyChanges;
  Done := False;
end;

procedure TOpenGLContext.Resize(Sender: TObject);
begin
  glViewport(0, 0, FForm.ClientWidth, FForm.ClientHeight);
  if Assigned(FOldResize) then
    FOldResize(Sender);
end;

constructor TOpenGLContext.Create(AUpdateFunc, ARenderFunc: TFunction; AForm: TForm);
begin
  FForm := AForm;
  FUpdateFunction := AUpdateFunc;
  FRenderFunction := ARenderFunc;
  Init;
end;

destructor TOpenGLContext.Destroy;
begin
  FInput.Free;

  FinalizeGL;
  inherited;
end;

end.

