unit Shaders;

interface

uses
  dglOpenGL, Dialogs, Classes, SysUtils, GLEnums, Controls, Forms, Lists
  {$IFNDEF FPC}
  , Types
  {$ELSE}
  , Windows // for RT_RCDATA
  {$ENDIF}
  ;

type

  { EShaderError }

  EShaderError = class (Exception)
  end;

  { EAttribNotFound }

  EAttribNotFound = class(EShaderError)
    constructor Create(Attribute: PAnsiChar);
  end;

  { EUniformNotFound }

  EUniformNotFound = class(EShaderError)
    constructor Create(Uniform: PAnsiChar);
  end;

  { TShader }

  TShader = class
  public
    type

      { TAttribute }

      TAttribute = class
      private
        FCount: Integer;
        FName: String;
        FDataType: TGLDataType;

      public
        constructor Create(ACount: Integer; AName: String; ADataType: TGLDataType);

        property Count: Integer read FCount;
        property Name: String read FName;
        property DataType: TGLDataType read FDataType;

      end;

  private
    FProgramObject: Integer;
    FLocations: TAnsiStringMap<Integer>;
    FAttributes: TObjectArray<TAttribute>;

    function CheckShaderErrors(AShaderName: String; AShader: GLHandle): Boolean;
    function CheckProgramErrors: Boolean;
    function GetAtributeCount: Integer;

    function GetAttribLocation(AName: PAnsiChar): Integer;
    function GetAttribute(I: Integer): TAttribute;
    function GetUniformLocation(AName: PAnsiChar): Integer;

    class var FActiveShader: TShader;

  public
    constructor Create;
    destructor Destroy; override;

    function AddShaderFromFile(ShaderType: TShaderType; Filename: String): Boolean;
    function AddShaderFromResource(ShaderType: TShaderType; ResourceName: String): Boolean;
    function Link: Boolean;

    function VertexFragmentShader(AName: String): Boolean;
    function VertexFragmentShaderFromResource(AName: String): Boolean;

    procedure AddAttribute(ACount: Integer; AName: String; ADataType: TGLDataType = dtFloat);
    property Attributes[I: Integer]: TAttribute read GetAttribute;
    property AttributeCount: Integer read GetAtributeCount;

    property UniformLocation[AName: PAnsiChar]: Integer read GetUniformLocation;
    property AttribLocation[AName: PAnsiChar]: Integer read GetAttribLocation;

    procedure Enable;
    class procedure Disable;

    property ProgramObject: Integer read FProgramObject;

    class property ActiveShader: TShader read FActiveShader;
  end;

implementation

{ TShader.TAttribute }

constructor TShader.TAttribute.Create(ACount: Integer; AName: String; ADataType: TGLDataType);
begin
  FCount := ACount;
  FName := AName;
  FDataType := ADataType;
end;

{ EUniformNotFound }

constructor EUniformNotFound.Create(Uniform: PAnsiChar);
begin
  inherited Create(Format('Shader Uniform "%s" could not be found!', [Uniform]));
end;

{ EAttribNotFound }

constructor EAttribNotFound.Create(Attribute: PAnsiChar);
begin
  inherited Create(Format('Vertex Attribute "%s" could not be found!', [Attribute]));
end;

{ TShader }

function TShader.AddShaderFromFile(ShaderType: TShaderType; Filename: String): Boolean;
  function LoadStringFromFile(Filename: String): AnsiString;
  var
    FS: TFileStream;
  begin
    FS := TFileStream.Create(Filename, fmOpenRead);
    try
      if FS.Size = 0 then
        raise Exception.Create(Filename + ' doesn''t have any Data!'); // TODO: Shader exceptions
      SetLength(Result, FS.Size);
      FS.ReadBuffer(Result[1], FS.Size);
    finally
      FS.Free;
      end;
  end;

var
  ShaderObject, ShaderLength: Integer;
  ShaderText: AnsiString;
begin
  ShaderObject := glCreateShader(Ord(ShaderType));

  try
    ShaderText := LoadStringFromFile(Filename);
    ShaderLength := Length(ShaderText);

    glShaderSource(ShaderObject, 1, @ShaderText, @ShaderLength);
    glCompileShader(ShaderObject);

    Result := CheckShaderErrors(ExtractFileName(Filename), ShaderObject);

    if Result then
      glAttachShader(FProgramObject, ShaderObject);

  finally
    glDeleteShader(ShaderObject);
  end;
end;


function TShader.AddShaderFromResource(ShaderType: TShaderType; ResourceName: String): Boolean;

  function LoadStringFromResource(Resourcename: String): AnsiString;
  begin
    with TResourceStream.Create(hInstance, Resourcename, RT_RCDATA) do
    begin
      SetLength(Result, Size);
      ReadBuffer(Result[1], Size);
      Free;
    end;
  end;

var
  ShaderObject, ShaderLength: Integer;
  ShaderText: AnsiString;
begin
  ShaderObject := glCreateShader(Ord(ShaderType));

  try
    ShaderText := LoadStringFromResource(ResourceName);
    ShaderLength := Length(ShaderText);

    glShaderSource(ShaderObject, 1, @ShaderText, @ShaderLength);
    glCompileShader(ShaderObject);

    Result := CheckShaderErrors(ResourceName, ShaderObject);

    if Result then
      glAttachShader(FProgramObject, ShaderObject);

  finally
    glDeleteShader(ShaderObject);
  end;

end;

function TShader.GetAttribLocation(AName: PAnsiChar): Integer;
begin
  if not FLocations.Get(AName, Result) then
  begin
    Result := glGetAttribLocation(FProgramObject, AName);
    FLocations[AName] := Result;
  end;
end;

function TShader.GetAttribute(I: Integer): TAttribute;
begin
  Result := FAttributes[I];
end;

function TShader.CheckShaderErrors(AShaderName: String; AShader: GLHandle): Boolean;
var
  blen, slen: GLInt;
  InfoLog: PAnsiChar;
begin
  glGetShaderiv(AShader, GL_INFO_LOG_LENGTH, @blen);
  if blen <= 1 then
    Exit(True);
  Result := False;
  GetMem(InfoLog, blen * SizeOf(Char));
  glGetShaderInfoLog(AShader, blen, slen, InfoLog);
  MessageDlg(AShaderName + ':' + sLineBreak + String(InfoLog), mtError, [mbOK], 0);
  Dispose(InfoLog);
end;

function TShader.CheckProgramErrors: Boolean;
var
  blen: GLInt;
  slen: PGLsizei;
  InfoLog: PAnsiChar;
begin
  glGetProgramiv(FProgramObject, GL_INFO_LOG_LENGTH, @blen);
  if blen <= 1 then
    Exit(True);
  Result := False;
  GetMem(InfoLog, blen * SizeOf(Char));
  glGetProgramInfoLog(FProgramObject, blen, slen, InfoLog);
  MessageDlg('Linking: ' + sLineBreak + InfoLog, mtError, [mbOK], 0);
  Dispose(InfoLog);
end;

function TShader.GetAtributeCount: Integer;
begin
  Result := FAttributes.Count;
end;

constructor TShader.Create;
begin
  FProgramObject := glCreateProgram;
  FLocations := TAnsiStringMap<Integer>.Create;
  FAttributes := TObjectArray<TAttribute>.Create;
end;

destructor TShader.Destroy;
begin
  FLocations.Free;
  FAttributes.Free;
  glDeleteProgram(FProgramObject);
  inherited;
end;

class procedure TShader.Disable;
begin
  glUseProgram(0);
end;

procedure TShader.Enable;
begin
  if Pointer(FActiveShader) <> Pointer(Self) then
  begin
    glUseProgram(FProgramObject);
    FActiveShader := Self;
  end;
end;

function TShader.Link: Boolean;
begin
  glLinkProgram(FProgramObject);
  Result := CheckProgramErrors;
  if Result then
    Enable;
end;

function TShader.GetUniformLocation(AName: PAnsiChar): Integer;
begin
  if not FLocations.Get(AName, Result) then
  begin
    Result := glGetUniformLocation(FProgramObject, AName);
    FLocations[AName] := Result;
  end;
end;

function TShader.VertexFragmentShader(AName: String): Boolean;
begin
  Result := AddShaderFromFile(stVertex, AName + '.vs') and
            AddShaderFromFile(stFragment, AName + '.fs') and
            Link;
end;

function TShader.VertexFragmentShaderFromResource(AName: String): Boolean;
begin
  Result := AddShaderFromResource(stVertex, AName + '_VS') and
            AddShaderFromResource(stFragment, AName + '_FS') and
            Link;
end;

procedure TShader.AddAttribute(ACount: Integer; AName: String; ADataType: TGLDataType);
begin
  FAttributes.Add(TAttribute.Create(ACount, AName, ADataType));
end;

end.
