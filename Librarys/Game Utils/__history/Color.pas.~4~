unit Color;

interface

uses
  Graphics, dglOpenGL, VectorGeometry;

type

  { TColorRGBA }

  TColorRGBA = record
  private
    procedure SetA(AValue: Single); inline;
    procedure SetB(AValue: Single); inline;
    procedure SetG(AValue: Single); inline;
    procedure SetR(AValue: Single); inline;
  public
    FR, FG, FB, FA: Single;

    class operator Add(A, B: TColorRGBA): TColorRGBA;
    class operator Subtract(A, B: TColorRGBA): TColorRGBA;
    class operator Multiply(A, B: TColorRGBA): TColorRGBA;
    class operator Multiply(A: TColorrGBA; V: Single): TColorRGBA;
    class operator Multiply(V: Single; A: TColorrGBA): TColorRGBA;
    class operator LogicalNot(A: TColorRGBA): TColorRGBA;
    class operator Equal(A, B: TColorRGBA): Boolean;
    class operator NotEqual(A, B: TColorRGBA): Boolean;

    class function New(AColor: TColor; A: Single): TColorRGBA; overload; static; inline;
    class function New(R, G, B: Single; A: Single = 1): TColorRGBA; overload; static; inline;
    class function HSV(H, S, V: Single; A: Single = 1): TColorRGBA; overload; static; inline;

    class function Gray(V: Single; A: Single = 1): TColorRGBA; static; inline;
    class function Rainbow(H: Single; A: Single = 1): TColorRGBA; static; inline;

    class operator Implicit(AValue: TColorRGBA): TGVector4;
    class operator Implicit(AValue: TColor): TColorRGBA;

    property R: Single read FR write SetR;
    property G: Single read FG write SetG;
    property B: Single read FB write SetB;
    property A: Single read FA write SetA;

    function ToWinColor: TColor; inline;
  end;

  TColorRGB = record
  private
    procedure SetB(AValue: Single); inline;
    procedure SetG(AValue: Single); inline;
    procedure SetR(AValue: Single); inline;
  public
    FR, FG, FB: Single;

    class operator Add(A, B: TColorRGB): TColorRGB; inline;
    class operator Subtract(A, B: TColorRGB): TColorRGB; inline;
    class operator Multiply(A, B: TColorRGB): TColorRGB; inline;
    class operator Multiply(A: TColorrGB; V: Single): TColorRGB; inline;
    class operator Multiply(V: Single; A: TColorrGB): TColorRGB; inline;
    class operator LogicalNot(A: TColorRGB): TColorRGB; inline;
    class operator Equal(A, B: TColorRGB): Boolean; inline;
    class operator NotEqual(A, B: TColorRGB): Boolean; inline;

    class function New(Color: TColor): TColorRGB; overload; static;
    class function New(R, G, B: Single): TColorRGB; overload; static;
    class function HSV(H, S, V: Single): TColorRGB; overload; static;

    class function Gray(V: Single): TColorRGB; static;
    class function Rainbow(H: Single): TColorRGB; static;

    function ToRGBA(A: Single): TColorRGBA; inline;

    class operator Implicit(AValue: TColorRGBA): TColorRGB;
    class operator Implicit(AValue: TColorRGB): TColorRGBA;

    class operator Implicit(AValue: TColorRGB): TGVector3;

    property R: Single read FR write SetR;
    property G: Single read FG write SetG;
    property B: Single read FB write SetB;

    function ToWinColor: TColor; inline;
  end;

type
  TConstColor = (
    ccNone,
    ccWhite,
    ccBlack,
    ccGray,
    ccRed,
    ccLime,
    ccGreen,
    ccBlue,
    ccYellow,
    ccOrange,
    ccCyan,
    ccMagenta,
    ccPurple,
    ccDarkRed,
    ccDarkBlue
  );

const
  ConstColor: array [TConstColor] of TColorRGBA = (
    (FR: 0.0; FG: 0.0; FB: 0.0; FA: 0.0), // ccNone
    (FR: 1.0; FG: 1.0; FB: 1.0; FA: 1.0), // ccWhite
    (FR: 0.0; FG: 0.0; FB: 0.0; FA: 1.0), // ccBlack
    (FR: 0.5; FG: 0.5; FB: 0.5; FA: 1.0), // ccGray
    (FR: 1.0; FG: 0.0; FB: 0.0; FA: 1.0), // ccRed
    (FR: 0.0; FG: 1.0; FB: 0.0; FA: 1.0), // ccLime
    (FR: 0.0; FG: 0.5; FB: 0.0; FA: 1.0), // ccGreen
    (FR: 0.0; FG: 0.0; FB: 1.0; FA: 1.0), // ccBlue
    (FR: 1.0; FG: 1.0; FB: 0.0; FA: 1.0), // ccYellow
    (FR: 1.0; FG: 0.5; FB: 0.0; FA: 1.0), // ccOrange
    (FR: 0.0; FG: 1.0; FB: 1.0; FA: 1.0), // ccCyan
    (FR: 1.0; FG: 0.0; FB: 1.0; FA: 1.0), // ccMagenta
    (FR: 0.5; FG: 0.0; FB: 1.0; FA: 1.0), // ccPurple
    (FR: 0.5; FG: 0.0; FB: 0.0; FA: 1.0), // ccDarkRed
    (FR: 0.0; FG: 0.0; FB: 0.5; FA: 1.0)  // ccDarkBlue
  );
implementation

uses
  Math;

{ TColorRGB }

procedure TColorRGB.SetB(AValue: Single);
begin
  if FB = AValue then
    Exit;
  FB := EnsureRange(AValue, 0, 1);
end;

procedure TColorRGB.SetG(AValue: Single);
begin
  if FG = AValue then
    Exit;
  FG := EnsureRange(AValue, 0, 1);
end;

procedure TColorRGB.SetR(AValue: Single);
begin
  if FR = AValue then
    Exit;
  FR := EnsureRange(AValue, 0, 1);
end;

class operator TColorRGB.Add(A, B: TColorRGB): TColorRGB;
begin
  Result.R := A.R + B.R;
  Result.G := A.G + B.G;
  Result.B := A.B + B.B;
end;

class operator TColorRGB.Subtract(A, B: TColorRGB): TColorRGB;
begin
  Result.R := A.R - B.R;
  Result.G := A.G - B.G;
  Result.B := A.B - B.B;
end;

class operator TColorRGB.Multiply(A, B: TColorRGB): TColorRGB;
begin
  Result.R := A.R * B.R;
  Result.G := A.G * B.G;
  Result.B := A.B * B.B;
end;

class operator TColorRGB.Multiply(A: TColorrGB; V: Single): TColorRGB;
begin
  Result.R := A.R * V;
  Result.G := A.G * V;
  Result.B := A.B * V;
end;

class operator TColorRGB.Multiply(V: Single; A: TColorrGB): TColorRGB;
begin
  Result.R := V * A.R;
  Result.G := V * A.G;
  Result.B := V * A.B;
end;

class operator TColorRGB.LogicalNot(A: TColorRGB): TColorRGB;
begin
  Result.R := 1 - A.R;
  Result.G := 1 - A.G;
  Result.B := 1 - A.B;
end;

class operator TColorRGB.Equal(A, B: TColorRGB): Boolean;
begin
  Result := (A.R = B.R) and (A.G = B.G) and (A.B = B.B);
end;

class operator TColorRGB.NotEqual(A, B: TColorRGB): Boolean;
begin
   Result := (A.R <> B.R) or (A.G <> B.G) or (A.B <> B.B);
end;

class function TColorRGB.New(Color: TColor): TColorRGB;
begin
  Result.R := Color and $FF / $FF;
  Result.G := Color shr 8 and $FF / $FF;
  Result.B := Color shr 16 and $FF / $FF;
end;

class function TColorRGB.New(R, G, B: Single): TColorRGB;
begin
  Result.R := R;
  Result.G := G;
  Result.B := B;
end;

class function TColorRGB.HSV(H, S, V: Single): TColorRGB;

  function HMod(H: Single): Integer; inline;
  begin
    Result := Floor(H * 6);
  end;

  function F: Single; inline;
  begin
    Result := H * 6 - HMod;
  end;

  function P: Single; inline;
  begin
    Result := V * (1 - S);
  end;

  function Q: Single; inline;
  begin
    Result := V * (1 - S * F);
  end;

  function T: Single; inline;
  begin
    Result := V * (1 - S * (1 - F));
  end;

begin
  // TODO
  H := frac(H);
  case HMod of
    0: Result := New(V, T, P);
    1: Result := New(Q, V, P);
    2: Result := New(P, V, T);
    3: Result := New(P, Q, V);
    4: Result := New(T, P, V);
    5: Result := New(V, P, Q);
  end;
end;

class function TColorRGB.Gray(V: Single): TColorRGB;
begin
  Result.R := V;
  Result.G := V;
  Result.B := V;
end;

class function TColorRGB.Rainbow(H: Single): TColorRGB;
begin
  Result := HSV(H, 1, 1);
end;

function TColorRGB.ToRGBA(A: Single): TColorRGBA;
begin
  Result.R := R;
  Result.G := G;
  Result.B := B;
  Result.A := A;
end;

class operator TColorRGB.Implicit(AValue: TColorRGBA): TColorRGB;
begin
  Result.R := AValue.R;
  Result.G := AValue.G;
  Result.B := AValue.B;
end;

class operator TColorRGB.Implicit(AValue: TColorRGB): TColorRGBA;
begin
  Result := AValue.ToRGBA(1);
end;

class operator TColorRGB.Implicit(AValue: TColorRGB): TGVector3;
begin
  Move(AValue, Result, SizeOf(Single) * 3);
end;

function TColorRGB.ToWinColor: TColor;
begin
  Result := Floor(R * $FF) or Floor(G * $FF) shl 8 or Floor(B * $FF) shl 16;
end;

{ TColorRGBA }

procedure TColorRGBA.SetA(AValue: Single);
begin
  if FA = AValue then
    Exit;
  FA := EnsureRange(AValue, 0, 1);
end;

procedure TColorRGBA.SetB(AValue: Single);
begin
  if FB = AValue then
    Exit;
  FB := EnsureRange(AValue, 0, 1);
end;

procedure TColorRGBA.SetG(AValue: Single);
begin
  if FG = AValue then
    Exit;
  FG := EnsureRange(AValue, 0, 1);
end;

procedure TColorRGBA.SetR(AValue: Single);
begin
  if FR = AValue then
    Exit;
  FR := EnsureRange(AValue, 0, 1);
end;

class operator TColorRGBA.Add(A, B: TColorRGBA): TColorRGBA;
begin
  Result.R := Min(A.R + B.R, 1);
  Result.G := Min(A.G + B.G, 1);
  Result.B := Min(A.B + B.B, 1);
  Result.A := A.A;
end;

class operator TColorRGBA.Equal(A, B: TColorRGBA): Boolean;
begin
  Result := (A.R = B.R) and (A.G = B.G) and (A.B = B.B);
end;

class operator TColorRGBA.LogicalNot(A: TColorRGBA): TColorRGBA;
begin
  Result.R := 1 - A.R;
  Result.G := 1 - A.G;
  Result.B := 1 - A.B;
  Result.A := A.A;
end;

class operator TColorRGBA.Multiply(A, B: TColorRGBA): TColorRGBA;
begin
  Result.R := A.R * B.R;
  Result.G := A.G * B.G;
  Result.B := A.B * B.B;
  Result.A := A.A;
end;

class operator TColorRGBA.Multiply(A: TColorrGBA; V: Single): TColorRGBA;
begin
  Result.R := A.R * V;
  Result.G := A.G * V;
  Result.B := A.B * V;
  Result.A := A.A;
end;

class operator TColorRGBA.Multiply(V: Single; A: TColorrGBA): TColorRGBA;
begin
  Result.R := V  * A.R;
  Result.G := V  * A.G;
  Result.B := V  * A.B;
  Result.A := A.A;
end;

class operator TColorRGBA.NotEqual(A, B: TColorRGBA): Boolean;
begin
  Result := (A.R <> B.R) or (A.G <> B.G) or (A.B <> B.B);
end;

class function TColorRGBA.New(AColor: TColor; A: Single): TColorRGBA;
begin
  Result := TColorRGB.New(AColor);
  Result.A := A;
end;

class function TColorRGBA.New(R, G, B: Single; A: Single): TColorRGBA;
begin
  Result := TColorRGB.New(R, G, B);
  Result.A := A;
end;

class function TColorRGBA.HSV(H, S, V: Single; A: Single): TColorRGBA;
begin
  Result := TColorRGB.HSV(H, S, V);
  Result.A := A;
end;

class function TColorRGBA.Gray(V: Single; A: Single): TColorRGBA;
begin
  Result := TColorRGB.Gray(V);
  Result.A := A;
end;

class function TColorRGBA.Rainbow(H: Single; A: Single): TColorRGBA;
begin
  Result := TColorRGB.Rainbow(H);
  Result.A := A;
end;

class operator TColorRGBA.Implicit(AValue: TColorRGBA): TGVector4;
begin
  Move(AValue, Result, SizeOf(Single) * 4);
end;

class operator TColorRGBA.Implicit(AValue: TColor): TColorRGBA;
begin
  Result := New(AValue, 1);
end;

function TColorRGBA.ToWinColor: TColor;
begin
  Result := TColorRGB(Self).ToWinColor;
end;

class operator TColorRGBA.Subtract(A, B: TColorRGBA): TColorRGBA;
begin
  Result.R := A.R - B.R;
  Result.G := A.G - B.G;
  Result.B := A.B - B.B;
  Result.B := A.A;
end;

end.
