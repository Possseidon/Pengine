unit OpenGLContext;

interface

// TODO: Application.On(De)Activate trigger some function to handle it ingame

uses
  dglOpenGL, Forms, SysUtils, Controls, Windows, Classes, GLEnums, Color, InputHandler, TimeManager, Lists;

type

  { TOpenGLContext }

  TFunction = procedure of object;

  { TOpenGLState }

  // steps to add state:
  // 1) TState enum
  // 2) property
  // 3) Update Function
  // 4) Pop
  // 5) copy
  // 6) initialization (important for pop to main state)

  TOpenGLState = class
  public
    type
      TState = (
        stClearColor,
        stDepthFunc,
        stCullFace,
        stDepthTest,
        stBlend,
        stBlendFunc,
        stDepthMask
      );
     TStates = set of TState;
  private
    FBlend: Boolean;
    FBlendFunc: TGLBlendingFunc;
    FClearColor: TColorRGBA;
    FCullFace: Boolean;
    FDepthFunc: TGLCompareFunction;

    FChanges: TStates;
    FDepthMask: Boolean;
    FDepthTest: Boolean;

    procedure SetBlend(AValue: Boolean);
    procedure SetBlendFactorDest(AValue: TGLBlendingFactorDest);
    procedure SetBlendFactorSrc(AValue: TGLBlendingFactorSrc);
    procedure SetClearColor(AValue: TColorRGBA);
    procedure SetCullFace(AValue: Boolean);
    procedure SetDepthFunc(AValue: TGLCompareFunction);
    procedure SetDepthMask(AValue: Boolean);
    procedure SetDepthTest(AValue: Boolean);

  public
    function Copy: TOpenGLState;
    property Changes: TStates read FChanges;

    property ClearColor: TColorRGBA read FClearColor write SetClearColor;
    property DepthFunc: TGLCompareFunction read FDepthFunc write SetDepthFunc;
    property CullFace: Boolean read FCullFace write SetCullFace;
    property DepthTest: Boolean read FDepthTest write SetDepthTest;
    property Blend: Boolean read FBlend write SetBlend;
    property BlendFactorSrc: TGLBlendingFactorSrc read FBlendFunc.Src write SetBlendFactorSrc;
    property BlendFactorDest: TGLBlendingFactorDest read FBlendFunc.Dest write SetBlendFactorDest;
    property DepthMask: Boolean read FDepthMask write SetDepthMask;

    procedure UpdateClearColor;
    procedure UpdateDepthFunc;
    procedure UpdateCullFace;
    procedure UpdateDepthTest;
    procedure UpdateBlend;
    procedure UpdateBlendFunc;
    procedure UpdateDepthMask;
  end;

  TOpenGLContext = class
  private
    FFullscreen: Boolean;
    FMustUpdateFPS: Boolean;
    FVSync: Boolean;
    FForm: TForm;

    FInput: TInputHandler;
    FTimer: TDeltaTimer;

    FClearMask: TGLAttribMask;

    StateStack: TObjectStack;

    FDC: HDC;
    FRC: HGLRC;

    FUpdateFunction, FRenderFunction: TFunction;

    FOldResize: TNotifyEvent;
    FOldPaint: TNotifyEvent;

    FOldWindowState: TWindowState;

    procedure ActivateHandler(Sender: TObject);
    procedure DeactivateHandler(Sender: TObject);
    function GetDeltaTime: Single;
    function GetFPS: Single;
    function GetFPSInt: Cardinal;
    function GetSeconds: Single;
    function GetShowCursor: Boolean;
    function GetState: TOpenGLState;
    procedure Init;

    procedure InitGL;
    procedure FinalizeGL;

    procedure SetFullscreen(AValue: Boolean);
    procedure SetShowCursor(AValue: Boolean);
    procedure SetVSync(AValue: Boolean);

    procedure InitDefaults;

    procedure IdleHandler(Sender: TObject; var Done: Boolean);
    procedure Resize(Sender: TObject);
    procedure Paint(Sender: TObject);

  public
    constructor Create(AUpdateFunc, ARenderFunc: TFunction; AForm: TForm);
    destructor Destroy; override;

    procedure Render;

    property VSync: Boolean read FVSync write SetVSync;
    property Fullscreen: Boolean read FFullscreen write SetFullscreen;
    property ClearMask: TGLAttribMask read FClearMask write FClearMask;
    property ShowCursor: Boolean read GetShowCursor write SetShowCursor;

    property Input: TInputHandler read FInput;

    property DeltaTime: Single read GetDeltaTime;
    property FPS: Single read GetFPS;
    property FPSInt: Cardinal read GetFPSInt;
    property Seconds: Single read GetSeconds;
    property MustUpdateFPS: Boolean read FMustUpdateFPS;

    property State: TOpenGLState read GetState;

    procedure ForceFPSUpdate;

    procedure Push;
    procedure Pop;

    procedure Start;

    procedure Pause;
    procedure Continue;

  end;


implementation

uses
  Math;

{ TOpenGLState }

procedure TOpenGLState.SetClearColor(AValue: TColorRGBA);
begin
  if FClearColor = AValue then
    Exit;
  FClearColor := AValue;
  Include(FChanges, stClearColor);
  UpdateClearColor;
end;

procedure TOpenGLState.SetBlend(AValue: Boolean);
begin
  if FBlend = AValue then
    Exit;
  FBlend := AValue;
  Include(FChanges, stBlend);
  UpdateBlend;
end;

procedure TOpenGLState.SetBlendFactorDest(AValue: TGLBlendingFactorDest);
begin
  if FBlendFunc.Dest = AValue then
    Exit;
  FBlendFunc.Dest := AValue;
  Include(FChanges, stBlendFunc);
  UpdateBlendFunc;
end;

procedure TOpenGLState.SetBlendFactorSrc(AValue: TGLBlendingFactorSrc);
begin
  if FBlendFunc.Src = AValue then
    Exit;
  FBlendFunc.Src := AValue;
  Include(FChanges, stBlendFunc);
  UpdateBlendFunc;
end;

procedure TOpenGLState.SetCullFace(AValue: Boolean);
begin
  if FCullFace = AValue then
    Exit;
  FCullFace := AValue;
  Include(FChanges, stCullFace);
  UpdateCullFace;
end;

procedure TOpenGLState.SetDepthFunc(AValue: TGLCompareFunction);
begin
  if FDepthFunc = AValue then
    Exit;
  FDepthFunc := AValue;
  Include(FChanges, stDepthFunc);
  UpdateDepthFunc;
end;

procedure TOpenGLState.SetDepthMask(AValue: Boolean);
begin
  if FDepthMask = AValue then
    Exit;
  FDepthMask := AValue;
  Include(FChanges, stDepthMask);
  UpdateDepthMask;
end;

procedure TOpenGLState.SetDepthTest(AValue: Boolean);
begin
  if FDepthTest = AValue then
    Exit;
  FDepthTest := AValue;
  Include(FChanges, stDepthTest);
  UpdateDepthTest;
end;

function TOpenGLState.Copy: TOpenGLState;
begin
  Result := TOpenGLState.Create;

  Result.FClearColor := FClearColor;
  Result.FDepthFunc := FDepthFunc;
  Result.FBlend := FBlend;
  Result.FBlendFunc := FBlendFunc;
  Result.FDepthTest := FDepthTest;
  Result.FCullFace := FCullFace;
  Result.FDepthMask := FDepthMask;
end;

procedure TOpenGLState.UpdateClearColor;
begin
  glClearColor(FClearColor.R, FClearColor.G, FClearColor.B, FClearColor.A);
end;

procedure TOpenGLState.UpdateDepthFunc;
begin
  glDepthFunc(Ord(FDepthFunc));
end;

procedure TOpenGLState.UpdateCullFace;
begin
  if FCullFace then
    glEnable(GL_CULL_FACE)
  else
    glDisable(GL_CULL_FACE);
end;

procedure TOpenGLState.UpdateDepthTest;
begin
  if FDepthTest then
    glEnable(GL_DEPTH_TEST)
  else
    glDisable(GL_DEPTH_TEST);
end;

procedure TOpenGLState.UpdateBlend;
begin
  if FBlend then
    glEnable(GL_BLEND)
  else
    glDisable(GL_BLEND);
end;

procedure TOpenGLState.UpdateBlendFunc;
begin
  glBlendFunc(Ord(FBlendFunc.Src), Ord(FBlendFunc.Dest));
end;

procedure TOpenGLState.UpdateDepthMask;
begin
  glDepthMask(FDepthMask);
end;

{ TOpenGLContext }

procedure TOpenGLContext.Init;
begin
  InitGL;

  FInput := TInputHandler.Create(FForm);
  FTimer.Init;

  VSync := False;
  FFullscreen := False;

  ClearMask := amColorDepth;

  wglSwapIntervalEXT(Integer(FVSync));
end;

function TOpenGLContext.GetDeltaTime: Single;
begin
  Result := FTimer.DeltaTime;
end;

procedure TOpenGLContext.ActivateHandler(Sender: TObject);
begin
  if Fullscreen then
  begin
    FForm.AlphaBlend := False;
  end;
end;

procedure TOpenGLContext.DeactivateHandler(Sender: TObject);
begin
  FInput.ReleaseAll;
  if Fullscreen then
  begin
    FForm.AlphaBlend := True;
    FForm.AlphaBlendValue := 0;
  end;
end;

function TOpenGLContext.GetFPS: Single;
begin
  Result := FTimer.FPS;
end;

function TOpenGLContext.GetFPSInt: Cardinal;
begin
  Result := Floor(FTimer.FPS + 0.5);
end;

function TOpenGLContext.GetSeconds: Single;
begin
  Result := FTimer.Seconds;
end;

function TOpenGLContext.GetShowCursor: Boolean;
begin
  Result := FForm.Cursor <> -1;
end;

function TOpenGLContext.GetState: TOpenGLState;
begin
  Result := TOpenGLState(StateStack.Top);
end;

procedure TOpenGLContext.InitGL;
begin
  FDC := GetDC(FForm.Handle);
  FRC := CreateRenderingContextVersion(FDC, [opDoubleBuffered], 4, 2, True, 32, 24, 0, 0, 0, 0);
  ActivateRenderingContext(FDC, FRC);

  StateStack := TObjectStack.Create;
  StateStack.Push(TOpenGLState.Create);
  InitDefaults;
end;

procedure TOpenGLContext.Start;
begin
  FOldResize := FForm.OnResize;
  FOldPaint := FForm.OnPaint;
  FForm.OnResize := Resize;
  FForm.OnPaint := Paint;

  Application.AddOnDeactivateHandler(DeactivateHandler);
  Application.AddOnActivateHandler(ActivateHandler);
  Application.OnIdle := IdleHandler;
end;

procedure TOpenGLContext.Pause;
begin
  FInput.ReleaseAll;
  Application.OnIdle := nil;
end;

procedure TOpenGLContext.Continue;
begin
  FTimer.Update;
  Application.OnIdle := IdleHandler;
end;

procedure TOpenGLContext.FinalizeGL;
begin
  StateStack.Free;

  DeactivateRenderingContext;
  DestroyRenderingContext(FRC);
  ReleaseDC(FForm.Handle, FDC);
end;

procedure TOpenGLContext.SetFullscreen(AValue: Boolean);
var
  Flags: LONG;
begin
  FFullscreen := AValue;

  if FFullscreen then
  begin
    // activate fullscreen
    {$IFDEF FPC}
      FForm.FormStyle := fsSystemStayOnTop;
    {$ELSE}
      FForm.FormStyle := fsStayOnTop;
    {$ENDIF}
    Flags := GetWindowLong(FForm.Handle, GWL_STYLE);
    Flags := Flags
      and not WS_BORDER
      and not WS_CAPTION
      and not WS_THICKFRAME;
    SetWindowLong(FForm.Handle, GWL_STYLE, Flags);
    FOldWindowState := FForm.WindowState;
    FForm.WindowState := wsNormal;
    FForm.WindowState := wsMaximized;
  end
  else
  begin
    // deactivate fullscreen
    FForm.FormStyle := fsNormal;
    Flags := GetWindowLong(FForm.Handle, GWL_STYLE);
    Flags := Flags
      or WS_BORDER
      or WS_CAPTION
      or WS_THICKFRAME;
    SetWindowLong(FForm.Handle, GWL_STYLE, Flags);
    FForm.WindowState := wsNormal;
    FForm.WindowState := FOldWindowState;
  end;

end;

procedure TOpenGLContext.SetShowCursor(AValue: Boolean);
begin
  FForm.Cursor := TCursor(AValue) - 1;
end;

procedure TOpenGLContext.SetVSync(AValue: Boolean);
begin
  if FVSync = AValue then
    Exit;
  FVSync := AValue;
  wglSwapIntervalEXT(Integer(FVSync));
end;

procedure TOpenGLContext.InitDefaults;
begin
  State.DepthFunc := cfLess; // default
  State.ClearColor := ColorTransparent; // default
  State.DepthTest := True;
  State.CullFace := True;
  State.Blend := True;
  State.BlendFactorSrc := bfsSrcAlpha;
  State.BlendFactorDest := bfdOneMinusSrcAlpha;
  State.FDepthMask := True; // default
end;

procedure TOpenGLContext.IdleHandler(Sender: TObject; var Done: Boolean);
begin
  FMustUpdateFPS := FTimer.Update;
  if Assigned(FUpdateFunction) then
    FUpdateFunction;

  Render;

  Input.NotifyChanges;

  Done := False;
end;

procedure TOpenGLContext.Resize(Sender: TObject);
begin
  glViewport(0, 0, FForm.ClientWidth, FForm.ClientHeight);
  if Assigned(FOldResize) then
    FOldResize(Sender);
end;

procedure TOpenGLContext.Paint(Sender: TObject);
begin
  if Assigned(FOldPaint) then
    FOldPaint(Sender);
  Render;
end;

procedure TOpenGLContext.Render;
begin
  glClear(Ord(ClearMask));
  if Assigned(FRenderFunction) then
    FRenderFunction;
  SwapBuffers(FDC);
end;

procedure TOpenGLContext.ForceFPSUpdate;
begin
  FTimer.ForceFPSUpdate;
end;

constructor TOpenGLContext.Create(AUpdateFunc, ARenderFunc: TFunction; AForm: TForm);
begin
  FForm := AForm;
  FUpdateFunction := AUpdateFunc;
  FRenderFunction := ARenderFunc;
  Init;
end;

destructor TOpenGLContext.Destroy;
begin
  Pause;
  FInput.Free;
  FinalizeGL;
  inherited;
end;

procedure TOpenGLContext.Push;
begin
  StateStack.Push(State.Copy);
end;

procedure TOpenGLContext.Pop;
var
  S: TOpenGLState.TState;
  Changes: TOpenGLState.TStates;
begin
  Changes := State.Changes;
  StateStack.Pop.Free;
  for S in Changes do
  begin
    case S of
      stClearColor:
        State.UpdateClearColor;
      stDepthFunc:
        State.UpdateDepthFunc;
      stCullFace:
        State.UpdateCullFace;
      stDepthTest:
        State.UpdateDepthTest;
      stBlend:
        State.UpdateBlend;
      stBlendFunc:
        State.UpdateBlendFunc;
      stDepthMask:
        State.UpdateDepthMask;
    end;
  end;
end;

end.

