unit Camera;

{$IFDEF FPC}
{$mode Delphi}
{$ENDIF}

interface

uses
  dglOpenGL, VectorGeometry, Utils, Matrix, Shaders, SysUtils, System.Collection;

const
  RotMin = -180;
  RotMax = RotMin + 360;
  DefaultEpsilon = 1E-3; // Snap Value for Smooth Camera

type
  TMatrixType = (
    mtPosition,
    mtOffset,
    mtRotX, 
    mtRotY, 
    mtRotZ,
    mtRotation,
    mtModelView,
    mtProjection,
    mtMVP);

  TMatrixData = record
    Data: TMatrix4;
    Changed: Boolean;
    Location: Integer; // -1 = don't send to shader
  end;

  { TCamera }

  TCamera = class
  private
    // Rotation
    FTurnAngle: Single;
    FPitchAngle: Single;
    FRollAngle: Single;

    // Translation
    FPosition: TGVector;
    FOffset: TGVector;

    // Projection
    FFOV: Single;
    FAspect: Single;
    FFarClip: Single;
    FNearClip: Single;

    FOrtho: Boolean;
    FOrthoChanged: Boolean;
    FOrthoFactor: Single; // Zooms the whole scene
    
    FMat: array [TMatrixType] of TMatrixData;

    FShaders: array of TShader;

    function GetMatrix(I: TMatrixType): TMatrix4;
    function GetShaderCount: Integer;
    procedure SetPitchAngle(const Value: Single);
    procedure SetRollAngle(const Value: Single);
    procedure SetTurnAngle(const Value: Single);
    procedure SetPosition(const Value: TGVector);
    procedure SetOffset(const Value: TGVector);
    function GetLookDir: TGVector;
    function GetRightDir: TGVector;
    function GetUpDir: TGVector;
    function GetPitchRad: Single;
    function GetRollRad: Single;
    function GetTurnRad: Single;
    procedure SetPitchRad(const Value: Single);
    procedure SetRollRad(const Value: Single);
    procedure SetTurnRad(const Value: Single);
    procedure SetAspect(const Value: Single);
    procedure SetFarClip(const Value: Single);
    procedure SetFOV(const Value: Single);
    procedure SetNearClip(const Value: Single);
    procedure SetOrtho(const Value: Boolean);            

    procedure BuildPositionMatrix;
    procedure BuildOffsetMatrix;
    procedure BuildRotXMatrix;
    procedure BuildRotYMatrix;
    procedure BuildRotZMatrix;
    procedure BuildRotationMatrix;
    procedure BuildModelViewMatrix;
    procedure BuildProjectionMatrix;
    procedure BuildMVPMatrix;

    procedure SetOffsetX(const Value: Single);
    procedure SetOffsetY(const Value: Single);
    procedure SetOffsetZ(const Value: Single);

    procedure SetPositionX(const Value: Single);
    procedure SetPositionY(const Value: Single);
    procedure SetPositionZ(const Value: Single);
    procedure SetOrthoFactor(const Value: Single);

    procedure SetMatrixChanged(M: TMatrixType);

    function GetShaderID(AShader: TShader): Integer;

  public
    property TurnAngle: Single read FTurnAngle write SetTurnAngle;
    property PitchAngle: Single read FPitchAngle write SetPitchAngle;
    property RollAngle: Single read FRollAngle write SetRollAngle;

    property TurnRad: Single read GetTurnRad write SetTurnRad;
    property PitchRad: Single read GetPitchRad write SetPitchRad;
    property RollRad: Single read GetRollRad write SetRollRad;

    property Position: TGVector read FPosition write SetPosition;
    property PositionX: Single read FPosition.X write SetPositionX;
    property PositionY: Single read FPosition.Y write SetPositionY;
    property PositionZ: Single read FPosition.Z write SetPositionZ;

    property Offset: TGVector read FOffset write SetOffset;
    property OffsetX: Single read FOffset.X write SetOffsetX;
    property OffsetY: Single read FOffset.Y write SetOffsetY;
    property OffsetZ: Single read FOffset.Z write SetOffsetZ;

    property LookDir: TGVector read GetLookDir;
    property RightDir: TGVector read GetRightDir;
    property UpDir: TGVector read GetUpDir;

    property FOV: Single read FFOV write SetFOV;
    property Aspect: Single read FAspect write SetAspect;
    property NearClip: Single read FNearClip write SetNearClip;
    property FarClip: Single read FFarClip write SetFarClip;

    property Ortho: Boolean read FOrtho write SetOrtho;
    property OrthoFactor: Single read FOrthoFactor write SetOrthoFactor;

    procedure GetDirections(var Look, Right, Up: TGVector);

    procedure Slide(Distance: Single; IgnoreY: Boolean = False);
    procedure Lift(Distance: Single; OnlyY: Boolean = False);
    procedure Move(Distance: Single; IgnoreY: Boolean = False);

    procedure Turn(Angle: Single);
    procedure Pitch(Angle: Single);
    procedure Roll(Angle: Single);

    // Rotates around the current orientation of the Camera
    // Resets after any Default Pitch/Turn/Roll
    procedure FreeRotation(Angle : Single; Vec : TGVector);
    procedure FreeTurn(Angle: Single);
    procedure FreePitch(Angle: Single);
    procedure FreeRoll(Angle: Single);

    procedure LookAt(Point: TGVector);

    constructor Create(FOV, Aspect, NearClip, FarClip: Single);
    destructor Destroy; override;

    procedure Render;

    property Matrix[I: TMatrixType]: TMatrix4 read GetMatrix;

    property ShaderCount: Integer read GetShaderCount;

    // Todo: alles funktionen durchgehen, vor allem:
    function GetCursorLine(APos: TGVector2): TGLine;

    function GetRealPosition: TGVector;

    procedure AddShader(AShader: TShader);
    procedure RemoveShader(AShader: TShader);

    procedure SetUniformLocation(M: TMatrixType; Location: Integer);
    procedure ResetUniformLocation(M: TMatrixType);
  end;

  {
    TGLSmoothCamera = class(TCamera)
    private
    FVTurnAngle: Single;
    FVPitchAngle: Single;
    FVRollAngle: Single;

    FVPosition: TGLVector;
    FVOffset: TGLVector;

    FSmoothFactor: Single;
    FEpsilon: Single;

    procedure SetSmoothFactor(const Value: Single);
    function GetVLookDir: TGLVector;
    function GetVRightDir: TGLVector;
    function GetVUpDir: TGLVector;
    function GetVPitchRad: Single;
    function GetVRollRad: Single;
    function GetVTurnRad: Single;
    function GetVPitchAngle: Single;
    function GetVRollAngle: Single;
    function GetVTurnAngle: Single;
    procedure SetEpsilon(const Value: Single);

    public
    property Epsilon: Single read FEpsilon write SetEpsilon;
    property SmoothFactor: Single read FSmoothFactor write SetSmoothFactor;

    property VLookDir: TGLVector read GetVLookDir;
    property VRightDir: TGLVector read GetVRightDir;
    property VUpDir: TGLVector read GetVUpDir;

    property VTurnAngle: Single read GetVTurnAngle;
    property VPitchAngle: Single read GetVPitchAngle;
    property VRollAngle: Single read GetVRollAngle;

    property VTurnRad: Single read GetVTurnRad;
    property VPitchRad: Single read GetVPitchRad;
    property VRollRad: Single read GetVRollRad;

    property VPosition: TGLVector read FVPosition;
    property VOffset: TGLVector read FVOffset;

    procedure RenderOffset(Factor: Single = 1); override;
    procedure RenderRotation; override;
    procedure RenderMovement(Factor: Single = 1); override;
    procedure RenderOrthoScale; override;

    function Update(DeltaTime: Single): Boolean; overload;
    procedure Update; overload;

    constructor Create(FOV, Aspect, NearClip, FarClip, SmoothFactor: Single;
    CamEpsilon: Single = DefaultEpsilon);

    function GetCursorLine(X, Y: Single): TGLLine;
    procedure GetVDirections(var Look, Right, Up: TGLVector);
    end;
  }
implementation

uses
  Math;

{ TCamera }

procedure TCamera.BuildPositionMatrix;
begin
  FMat[mtPosition].Data[3, 0] := -Position.X;
  FMat[mtPosition].Data[3, 1] := -Position.Y;
  FMat[mtPosition].Data[3, 2] := -Position.Z;
  FMat[mtPosition].Changed := False;
end;

procedure TCamera.BuildModelViewMatrix;
begin
  if FMat[mtOffset].Changed then
    BuildOffsetMatrix;
  if FMat[mtRotation].Changed then
    BuildRotationMatrix;
  if FMat[mtPosition].Changed then
    BuildPositionMatrix;
    
  FMat[mtModelView].Data := FMat[mtOffset].Data * FMat[mtRotation].Data * FMat[mtPosition].Data;
  FMat[mtModelView].Changed := False;
end;

procedure TCamera.BuildMVPMatrix;
begin
  if FMat[mtModelView].Changed then
    BuildModelViewMatrix;
  if FMat[mtProjection].Changed then
    BuildProjectionMatrix;

  FMat[mtMVP].Data := FMat[mtProjection].Data * FMat[mtModelView].Data;
  FMat[mtMVP].Changed := False;
end;

procedure TCamera.BuildOffsetMatrix;
begin
  FMat[mtOffset].Data[3, 0] := -Offset.X;
  FMat[mtOffset].Data[3, 1] := -Offset.Y;
  FMat[mtOffset].Data[3, 2] := -Offset.Z;
  FMat[mtOffset].Changed := False;
end;

procedure TCamera.BuildProjectionMatrix;
var
  F: Single;
begin
  if FOrthoChanged then
  begin
    FMat[mtProjection].Data.Clear;
    FOrthoChanged := False;
  end;

  if Ortho then
  begin
    FMat[mtProjection].Data[0, 0] := OrthoFactor / Aspect;
    FMat[mtProjection].Data[1, 1] := OrthoFactor;
    FMat[mtProjection].Data[2, 2] := -2 / (FarClip - NearClip);
    FMat[mtProjection].Data[3, 2] := -(FarClip + NearClip) / (FarClip - NearClip);
    FMat[mtProjection].Data[3, 3] := 1;
  end
  else
  begin
    F := cot(FOV * Pi / 360);
    FMat[mtProjection].Data[0, 0] := F / Aspect;
    FMat[mtProjection].Data[1, 1] := F;
    FMat[mtProjection].Data[2, 2] := (NearClip + FarClip) / (NearClip - FarClip);
    FMat[mtProjection].Data[2, 3] := -1;
    FMat[mtProjection].Data[3, 2] := 2 * NearClip * FarClip / (NearClip - FarClip);
  end;
  FMat[mtProjection].Changed := False;    
end;

procedure TCamera.BuildRotationMatrix;
begin
  if FMat[mtRotX].Changed then
    BuildRotXMatrix;
  if FMat[mtRotY].Changed then
    BuildRotYMatrix;
  if FMat[mtRotZ].Changed then
    BuildRotZMatrix;

  FMat[mtRotation].Data := FMat[mtRotZ].Data * FMat[mtRotX].Data * FMat[mtRotY].Data;
  FMat[mtRotation].Changed := False;
end;

procedure TCamera.BuildRotXMatrix;
begin
  FMat[mtRotX].Data[1, 1] := cos(PitchRad);
  FMat[mtRotX].Data[2, 1] := -sin(PitchRad);
  FMat[mtRotX].Data[1, 2] := sin(PitchRad);
  FMat[mtRotX].Data[2, 2] := cos(PitchRad);
  FMat[mtRotX].Changed := False;
end;

procedure TCamera.BuildRotYMatrix;
begin
  FMat[mtRotY].Data[0, 0] := cos(TurnRad);
  FMat[mtRotY].Data[2, 0] := sin(TurnRad);
  FMat[mtRotY].Data[0, 2] := -sin(TurnRad);
  FMat[mtRotY].Data[2, 2] := cos(TurnRad);
  FMat[mtRotY].Changed := False;
end;

procedure TCamera.BuildRotZMatrix;
begin
  FMat[mtRotZ].Data[0, 0] := cos(RollRad);
  FMat[mtRotZ].Data[1, 0] := -sin(RollRad);
  FMat[mtRotZ].Data[0, 1] := sin(RollRad);
  FMat[mtRotZ].Data[1, 1] := cos(RollRad);
  FMat[mtRotZ].Changed := False;
end;

constructor TCamera.Create(FOV, Aspect, NearClip, FarClip: Single);
var
  M: TMatrixType;
begin
  if FOV = 0 then
  begin
    FOrthoFactor := 1;
    FOrtho := True;
  end;

  FFOV := FOV;
  FAspect := Aspect;
  FNearClip := NearClip;
  FFarClip := FarClip;


  FMat[mtPosition].Data.LoadIdentity;
  FMat[mtOffset].Data.LoadIdentity;
  FMat[mtRotX].Data.LoadIdentity;
  FMat[mtRotY].Data.LoadIdentity;
  FMat[mtRotZ].Data.LoadIdentity;

  for M := Low(TMatrixType) to High(TMatrixType) do
  begin
    FMat[M].Changed := True;
    FMat[M].Location := -1;
  end;
end;

destructor TCamera.Destroy;
begin
  inherited;
end;
                    

function TCamera.GetCursorLine(APos: TGVector2): TGLine;
var
  Look, Right, Up: TGVector;
begin
  GetDirections(Look, Right, Up);
  if Ortho then
  begin
    Result.SV := (APos.X * Right * Aspect + APos.Y * Up) / OrthoFactor - Position;
    Result.DV := Look;
  end
  else
  begin
    Result.SV := Position + Right * OffsetX + Up * OffsetY - Look * OffsetZ;
    APos.X := APos.X * Tan(FOV / 360 * Pi);
    APos.Y := APos.Y * Tan(FOV / 360 * Pi);
    Result.DV := Look + APos.X * Right + APos.Y * Up;
  end;
end;

procedure TCamera.GetDirections(var Look, Right, Up: TGVector);
begin
  Look := LookDir;
  Right := RightDir;
  Up := UpDir;
end;

function TCamera.GetLookDir: TGVector;
begin
  if FMat[mtRotation].Changed then
    BuildRotationMatrix;
  Result.X := -FMat[mtRotation].Data[0, 2];
  Result.Y := -FMat[mtRotation].Data[1, 2];
  Result.Z := -FMat[mtRotation].Data[2, 2];
end;

function TCamera.GetPitchRad: Single;
begin
  Result := FPitchAngle * Pi / 180;
end;

function TCamera.GetRealPosition: TGVector;
var
  L, R, U: TGVector;
begin
  GetDirections(L, R, U);
  Result := Position + R * Offset.X + U * Offset.Y - L * Offset.Z;
end;

procedure TCamera.AddShader(AShader: TShader);
var
  I: Integer;
begin
  I := ShaderCount;
  SetLength(FShaders, I + 1);
  FShaders[I] := AShader;
end;

procedure TCamera.RemoveShader(AShader: TShader);
var
  I: Integer;
begin
  I := GetShaderID(AShader);
  if I = -1 then
    raise Exception.Create('Shader does not exist');
  FShaders[I].Free;
  System.Move(FShaders[I + 1], FShaders[I], SizeOf(FShaders[I]) * (ShaderCount - I - 1));
  SetLength(FShaders, ShaderCount - 1);
end;

function TCamera.GetRightDir: TGVector;
begin
  if FMat[mtRotation].Changed then
    BuildRotationMatrix;
  Result.X := FMat[mtRotation].Data[0, 0];
  Result.Y := FMat[mtRotation].Data[1, 0];
  Result.Z := FMat[mtRotation].Data[2, 0];
end;

function TCamera.GetRollRad: Single;
begin
  Result := FRollAngle * Pi / 180;
end;

function TCamera.GetTurnRad: Single;
begin
  Result := FTurnAngle * Pi / 180;
end;

function TCamera.GetUpDir: TGVector;
begin
  if FMat[mtRotation].Changed then
    BuildRotationMatrix;
  Result.X := FMat[mtRotation].Data[0, 1];
  Result.Y := FMat[mtRotation].Data[1, 1];
  Result.Z := FMat[mtRotation].Data[2, 1];
end;

procedure TCamera.Lift(Distance: Single; OnlyY: Boolean);
begin
  if OnlyY then
    Position := Position + Distance * UVecY
  else
    Position := Position + Distance * UpDir;
end;

procedure TCamera.LookAt(Point: TGVector);
var
  Dir: TGDirection;
begin
  Point := Point - Position;
  Dir := TGDirection.PointDir(Point);
  if not IsNan(Dir.T) then
    TurnRad := Dir.T;
  PitchRad := Dir.P;
end;

procedure TCamera.Move(Distance: Single; IgnoreY: Boolean = False);
begin
  if IgnoreY then
    Position := Position + Distance * UVecY.Cross(RightDir).Normalize
  else
    Position := Position + Distance * LookDir;
end;

procedure TCamera.Pitch(Angle: Single);
begin
  PitchAngle := PitchAngle + Angle;
end;

procedure TCamera.Render;
var
  M: TMatrixType;
begin  
  if FMat[mtMVP].Changed then
  begin
    BuildMVPMatrix;
    for M := Low(TMatrixType) to High(TMatrixType) do      
      if FMat[M].Location <> -1 then
      begin
        glUniformMatrix4fv(FMat[M].Location, 1, ByteBool(GL_FALSE), @FMat[M].Data);
      end;
  end;
end;

procedure TCamera.ResetUniformLocation(M: TMatrixType);
begin
  FMat[M].Location := -1;
end;

procedure TCamera.Roll(Angle: Single);
begin
  RollAngle := RollAngle + Angle;
end;

procedure TCamera.FreeRotation(Angle: Single; Vec: TGVector);
var
  S, C: Single;
  M: TMatrix4;
begin
  if FMat[mtRotation].Changed then
    BuildRotationMatrix;
  
  Vec := Vec.Normalize;
  
  S := Sin(Angle / 180 * Pi);
  C := Cos(Angle / 180 * Pi);
  
  M.Clear;
  
  M[0, 0] := Vec.X * Vec.X * (1 - C) + C;
  M[0, 1] := Vec.Y * Vec.X * (1 - C) + Vec.Z * S;
  M[0, 2] := Vec.Z * Vec.X * (1 - C) - Vec.Y * S;
  
  M[1, 0] := Vec.X * Vec.Y * (1 - C) - Vec.Z * S;        
  M[1, 1] := Vec.Y * Vec.Y * (1 - C) + C;
  M[1, 2] := Vec.Z * Vec.Y * (1 - C) + Vec.X * S;
  
  M[2, 0] := Vec.X * Vec.Z * (1 - C) + Vec.Y * S;        
  M[2, 1] := Vec.Y * Vec.Z * (1 - C) - Vec.X * S;
  M[2, 2] := Vec.Z * Vec.Z * (1 - C) + C;
  
  M[3, 3] := 1;  
  
  FMat[mtRotation].Data := FMat[mtRotation].Data * M;
  SetMatrixChanged(mtModelView);
end;

procedure TCamera.FreeTurn(Angle : Single);
begin
  FreeRotation(Angle, UpDir);
end;

procedure TCamera.FreePitch(Angle : Single);
begin
  FreeRotation(Angle, RightDir);
end;

procedure TCamera.FreeRoll(Angle : Single);
begin
  FreeRotation(Angle, -LookDir);
end;
                    
procedure TCamera.SetAspect(const Value: Single);
begin
  FAspect := Value;
  SetMatrixChanged(mtProjection);
end;

procedure TCamera.SetFarClip(const Value: Single);
begin
  FFarClip := Value;
  SetMatrixChanged(mtProjection);
end;

procedure TCamera.SetFOV(const Value: Single);
begin
  FFOV := Value;
  SetMatrixChanged(mtProjection);
end;

procedure TCamera.SetMatrixChanged(M: TMatrixType);
begin
  // any movement/rotation changes modelview
  FMat[mtModelView].Changed := FMat[mtModelView].Changed or 
    ((M >= mtPosition) and (M <= mtRotation));
  // any sub-rotation changes main-rotation
  FMat[mtRotation].Changed := FMat[mtRotation].Changed or
    ((M >= mtRotX) and (M <= mtRotZ));
  // given type changed
  FMat[M].Changed := True;
  // anything changed -> MVP changes
  FMat[mtMVP].Changed := True;
end;

function TCamera.GetShaderID(AShader: TShader): Integer;
var
  I: Integer;
begin
  for I := 0 to ShaderCount - 1 do
    if Pointer(FShaders[I]) = Pointer(AShader) then
      Exit(I);
end;

procedure TCamera.SetNearClip(const Value: Single);
begin
  FNearClip := Value;
  SetMatrixChanged(mtProjection);
end;

procedure TCamera.SetOffset(const Value: TGVector);
begin
  FOffset := Value;
  SetMatrixChanged(mtOffset);
end;

procedure TCamera.SetOffsetX(const Value: Single);
begin
  FOffset.X := Value;
  SetMatrixChanged(mtOffset);
end;

procedure TCamera.SetOffsetY(const Value: Single);
begin
  FOffset.Y := Value;
  SetMatrixChanged(mtOffset);
end;

procedure TCamera.SetOffsetZ(const Value: Single);
begin
  FOffset.Z := Value;
  SetMatrixChanged(mtOffset);
end;

procedure TCamera.SetOrtho(const Value: Boolean);
begin
  FOrtho := Value;
  FOrthoChanged := True;
  SetMatrixChanged(mtProjection);
end;

procedure TCamera.SetOrthoFactor(const Value: Single);
begin
  FOrthoFactor := Value;
  SetMatrixChanged(mtProjection);
end;

procedure TCamera.SetPitchAngle(const Value: Single);
begin
  FPitchAngle := RealMod(Value, RotMin, RotMax);
  SetMatrixChanged(mtRotX);
end;

function TCamera.GetMatrix(I: TMatrixType): TMatrix4;
begin
  Result := FMat[I].Data;
end;

function TCamera.GetShaderCount: Integer;
begin
  Result := Length(FShaders);
end;

procedure TCamera.SetPitchRad(const Value: Single);
begin
  PitchAngle := Value * 180 / Pi;
end;

procedure TCamera.SetPosition(const Value: TGVector);
begin
  FPosition := Value;
  SetMatrixChanged(mtPosition);
end;

procedure TCamera.SetPositionX(const Value: Single);
begin
  FPosition.X := Value;
  SetMatrixChanged(mtPosition);
end;

procedure TCamera.SetPositionY(const Value: Single);
begin
  FPosition.Y := Value;
  SetMatrixChanged(mtPosition);
end;

procedure TCamera.SetPositionZ(const Value: Single);
begin
  FPosition.Z := Value;
  SetMatrixChanged(mtPosition);
end;

procedure TCamera.SetRollAngle(const Value: Single);
begin
  FRollAngle := RealMod(Value, RotMin, RotMax);
  SetMatrixChanged(mtRotZ);
end;

procedure TCamera.SetRollRad(const Value: Single);
begin
  RollAngle := Value * 180 / Pi;
end;

procedure TCamera.SetTurnAngle(const Value: Single);
begin
  FTurnAngle := RealMod(Value, RotMin, RotMax);
  SetMatrixChanged(mtRotY);
end;

procedure TCamera.SetTurnRad(const Value: Single);
begin
  TurnAngle := Value * 180 / Pi;
end;

procedure TCamera.SetUniformLocation(M: TMatrixType; Location: Integer);
begin
  FMat[M].Location := Location;
end;

procedure TCamera.Slide(Distance: Single; IgnoreY: Boolean = False);
begin
  if IgnoreY then
    Position := Position + Distance * LookDir.Cross(UVecY).Normalize
  else
    Position := Position + Distance * RightDir;
end;

procedure TCamera.Turn(Angle: Single);
begin
  TurnAngle := TurnAngle + Angle;
end;

{ TGLSmoothCamera }
{
  constructor TGLSmoothCamera.Create(FOV, Aspect, NearClip, FarClip,
  SmoothFactor, CamEpsilon: Single);
  begin
  inherited Create(FOV, Aspect, NearClip, FarClip);
  FSmoothFactor := SmoothFactor;
  Epsilon := CamEpsilon;
  end;

  function TGLSmoothCamera.GetCursorLine(X, Y: Single): TGLLine;
  var
  Look, Right, Up: TGLVector;
  begin
  GetVDirections(Look, Right, Up);
  if Ortho then
  begin
  X := X * OffsetZ * Aspect;
  Y := Y * OffsetZ;
  Result.SV := VPosition + X * Right + Y * Up - Look * VOffset.Z;
  Result.DV := Look;
  end
  else
  begin
  Result.SV := VPosition + Right * VOffset.X + Up * VOffset.Y - Look *
  VOffset.Z;
  X := X * Tan(FOV / 360 * Pi) * Aspect;
  Y := Y * Tan(FOV / 360 * Pi);
  Result.DV := Look + X * Right + Y * Up;
  end;
  end;

  procedure TGLSmoothCamera.GetVDirections(var Look, Right, Up: TGLVector);
  begin
  Look := VLookDir;
  Right := VRightDir;
  Up := Right.Cross(Look);
  end;

  function TGLSmoothCamera.GetVLookDir: TGLVector;
  begin
  Result.X := Sin(VTurnRad) * Cos(VPitchRad);
  Result.Y := Sin(VPitchRad);
  Result.Z := -Cos(VTurnRad) * Cos(VPitchRad);
  end;

  function TGLSmoothCamera.GetVPitchAngle: Single;
  begin
  Result := FVPitchAngle;
  end;

  function TGLSmoothCamera.GetVPitchRad: Single;
  begin
  Result := VPitchAngle / 180 * Pi;
  end;

  function TGLSmoothCamera.GetVRightDir: TGLVector;
  begin
  Result.X := Cos(VTurnRad) * Cos(VRollRad);
  Result.Y := -Sin(VRollRad);
  Result.Z := Sin(VTurnRad) * Cos(VRollRad);
  end;

  function TGLSmoothCamera.GetVRollAngle: Single;
  begin
  Result := FVRollAngle;
  end;

  function TGLSmoothCamera.GetVRollRad: Single;
  begin
  Result := VRollAngle / 180 * Pi;
  end;

  function TGLSmoothCamera.GetVTurnAngle: Single;
  begin
  Result := FVTurnAngle;
  end;

  function TGLSmoothCamera.GetVTurnRad: Single;
  begin
  Result := VTurnAngle / 180 * Pi;
  end;

  function TGLSmoothCamera.GetVUpDir: TGLVector;
  begin
  Result := VRightDir.Cross(VLookDir);
  end;

  procedure TGLSmoothCamera.Init;
  begin
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity;
  if Ortho then
  begin
  Assert(VOffset.Z <> 0, 'Ortho Camera Z-Offset must not be 0!');
  glOrtho(-Aspect, Aspect, -1, 1, NearClip, FarClip)
  end
  else
  gluPerspective(FOV, Aspect, NearClip, FarClip);
  glMatrixMode(GL_MODELVIEW);
  end;

  procedure TGLSmoothCamera.RenderMovement(Factor: Single);
  begin
  glTranslatef(-VPosition.X * Factor, -VPosition.Y * Factor, -VPosition.Z * Factor);
  end;

  procedure TGLSmoothCamera.RenderOffset(Factor: Single);
  begin
  glTranslatef(-VOffset.X * Factor, -VOffset.Y * Factor, -VOffset.Z * Factor);
  end;

  procedure TGLSmoothCamera.RenderOrthoScale;
  begin
  glScalef(1 / VOffset.Z, 1 / VOffset.Z, 1 / VOffset.Z);
  end;

  procedure TGLSmoothCamera.RenderRotation;
  begin
  glRotatef(VRollAngle, 0, 0, 1);
  glRotatef(-VPitchAngle, 1, 0, 0);
  glRotatef(VTurnAngle, 0, 1, 0);
  end;

  procedure TGLSmoothCamera.SetEpsilon(const Value: Single);
  begin
  FEpsilon := Value;
  end;

  procedure TGLSmoothCamera.SetSmoothFactor(const Value: Single);
  begin
  Assert(Value > 0, 'SmoothFactor %f must not be less than 0 !');
  FSmoothFactor := Value;
  end;

  function TGLSmoothCamera.Update(DeltaTime: Single): Boolean;
  var
  D: Single;

  procedure UpdateRotation(var IsValue: Single; const ToValue: Single;
  Min, Max: Single);
  var
  R: Single;
  begin
  R := Max - Min;
  if Abs(ToValue - IsValue) < Epsilon then
  IsValue := ToValue
  else
  begin
  if ToValue - IsValue > R / 2 then
  IsValue := RealMod(IsValue - (R - ToValue + IsValue) * D, Min, Max)
  else if IsValue - ToValue > R / 2 then
  IsValue := RealMod(IsValue + (R - IsValue + ToValue) * D, Min, Max)
  else
  IsValue := IsValue + (ToValue - IsValue) * D;
  Result := True;
  end;
  end;

  procedure UpdateTranslation(var IsValue: TGLVector; const ToValue: TGLVector);
  begin
  if (ToValue - IsValue).Length < Epsilon then
  IsValue := ToValue
  else
  begin
  IsValue := IsValue + (ToValue - IsValue) * D;
  Result := True;
  end;
  end;

  begin
  Result := False;

  //D := 1 - 1 / (DeltaTime * SmoothFactor + 1);

  D := 1 - exp(-DeltaTime * SmoothFactor);

  UpdateRotation(FVTurnAngle, TurnAngle, RotMin, RotMax);
  UpdateRotation(FVPitchAngle, PitchAngle, RotMin, RotMax);
  UpdateRotation(FVRollAngle, RollAngle, RotMin, RotMax);

  UpdateTranslation(FVPosition, Position);
  UpdateTranslation(FVOffset, Offset);
  end;

  procedure TGLSmoothCamera.Update;
  begin
  FVTurnAngle := TurnAngle;
  FVPitchAngle := PitchAngle;
  FVRollAngle := RollAngle;

  FVPosition := Position;
  FVOffset := Offset;
  end;
}
end.
