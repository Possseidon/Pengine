unit VectorGeometry;

interface

uses
  Matrix, SysUtils, dglOpenGL, Math, Utils;

type
  TSingleArray = array of Single;

  TGBasicDir = (sdRight, sdLeft, sdUp, sdDown, sdFront, sdBack);
  TGBasicDir3 = sdRight..sdBack;
  TGBasicDir2 = sdRight..sdDown;

  { TGVector }

  TGVector = record
  public
    X, Y, Z, W: Single;

    class operator Add(A, B: TGVector): TGVector;
    class operator Subtract(A, B: TGVector): TGVector;

    class operator Add(A: TGVector; V: Single): TGVector;
    class operator Subtract(A: TGVector; V: Single): TGVector;

    class operator Multiply(A: TGVector; V: Single): TGVector;
    class operator Multiply(V: Single; A: TGVector): TGVector;
    class operator Multiply(A, B: TGVector): TGVector;

    class operator Multiply(A: TMatrix4; B: TGVector): TGVector;

    class operator Divide(A: TGVector; V: Single): TGVector;
    class operator Divide(V: Single; A: TGVector): TGVector;
    class operator Divide(A, B: TGVector): TGVector;

    class operator Negative(A: TGVector): TGVector;

    class operator Equal(A, B: TGVector): Boolean;
    class operator NotEqual(A, B: TGVector): Boolean;
    class operator LessThan(A, B: TGVector): Boolean;
    class operator LessThanOrEqual(A, B: TGVector): Boolean;
    class operator GreaterThan(A, B: TGVector): Boolean;
    class operator GreaterThanOrEqual(A, B: TGVector): Boolean;

    class operator Implicit(A: TGVector): String;

    function Cross(A: TGVector): TGVector; inline;
    function Dot(A: TGVector): Single; inline;
    function SqrDot: Single; inline;
    function Length: Single; inline;
    function DistanceTo(A: TGVector): Single; inline;
    function VectorTo(A: TGVector): TGVector; inline;
    function Normalize: TGVector; inline;
    function GetAngel(A: TGVector): Single; inline;
    function Floor: TGVector; inline;
    function Ceil: TGVector; inline;

    function ToString: String; inline;

    function Rotate(A: TGVector; Angel: Single): TGVector;

    constructor Create(X, Y, Z: Single; W: Single = 1);

    property S: Single read X write X;
    property T: Single read Y write Y;
    property U: Single read Z write Z;
    property V: Single read W write W;
  end;

  TGVector4 = TGVector;

  { TGVector3 }

  TGVector3 = record
  public
    X, Y, Z: Single;

    class operator Add(A, B: TGVector3): TGVector3;
    class operator Subtract(A, B: TGVector3): TGVector3;

    class operator Add(A: TGVector3; V: Single): TGVector3;
    class operator Subtract(A: TGVector3; V: Single): TGVector3;

    class operator Multiply(V: Single; A: TGVector3): TGVector3;
    class operator Multiply(A: TGVector3; V: Single): TGVector3;
    class operator Multiply(A, B: TGVector3): TGVector3;

    class operator Divide(V: Single; A: TGVector3): TGVector3;
    class operator Divide(A: TGVector3; V: Single): TGVector3;

    class operator Negative(A: TGVector3): TGVector3;

    class operator Equal(A, B: TGVector3): Boolean;
    class operator NotEqual(A, B: TGVector3): Boolean;
    class operator LessThan(A, B: TGVector3): Boolean;
    class operator LessThanOrEqual(A, B: TGVector3): Boolean;
    class operator GreaterThan(A, B: TGVector3): Boolean;
    class operator GreaterThanOrEqual(A, B: TGVector3): Boolean;

    class operator Implicit(A: TGVector4): TGVector3;
    class operator Implicit(A: TGVector3): TGVector4;

    class operator Implicit(A: TGVector3): String;

    function ToVec4(W: Single = 1): TGVector4;

    function Cross(A: TGVector3): TGVector3; inline;
    function Dot(A: TGVector3): Single; inline;
    function SqrDot: Single; inline;
    function Length: Single; inline;
    function DistanceTo(A: TGVector3): Single; inline;
    function VectorTo(A: TGVector3): TGVector3; inline;
    function Normalize: TGVector3; inline;
    function GetAngel(A: TGVector3): Single; inline;
    function Floor: TGVector3; inline;
    function Ceil: TGVector3; inline;

    function ToString: String; inline;

    function Rotate(A: TGVector3; Angel: Single): TGVector3;

    constructor Create(X, Y, Z: Single);

    property S: Single read X write X;
    property T: Single read Y write Y;
    property U: Single read Z write Z;
  end;

  { TGVector2 }

  TGVector2 = record
  public
    X, Y: Single;

    class operator Add(A, B: TGVector2): TGVector2;
    class operator Subtract(A, B: TGVector2): TGVector2;

    class operator Add(A: TGVector2; V: Single): TGVector2;
    class operator Subtract(A: TGVector2; V: Single): TGVector2;

    class operator Multiply(V: Single; A: TGVector2): TGVector2;
    class operator Multiply(A: TGVector2; V: Single): TGVector2;
    class operator Multiply(A, B: TGVector2): TGVector2;

    class operator Divide(V: Single; A: TGVector2): TGVector2;
    class operator Divide(A: TGVector2; V: Single): TGVector2;

    class operator Negative(A: TGVector2): TGVector2;

    class operator Equal(A, B: TGVector2): Boolean;
    class operator NotEqual(A, B: TGVector2): Boolean;
    class operator LessThan(A, B: TGVector2): Boolean;
    class operator LessThanOrEqual(A, B: TGVector2): Boolean;
    class operator GreaterThan(A, B: TGVector2): Boolean;
    class operator GreaterThanOrEqual(A, B: TGVector2): Boolean;

    class operator Implicit(A: TGVector3): TGVector2;
    class operator Implicit(A: TGVector4): TGVector2;

    class operator Implicit(A: TGVector2): TGVector3;
    class operator Implicit(A: TGVector2): TGVector4;

    class operator Implicit(A: TGVector2): String;

    function ToVec3(Z: Single = 0): TGVector3;
    function ToVec4(Z: Single = 0; W: Single = 0): TGVector4;

    function Cross: TGVector2; inline; // = Rotate 90
    function Dot(A: TGVector2): Single; inline;
    function SqrDot: Single; inline;
    function Length: Single; inline;
    function DistanceTo(A: TGVector2): Single; inline;
    function VectorTo(A: TGVector2): TGVector2; inline;
    function Normalize: TGVector2; inline;
    function GetAngle(A: TGVector2): Single; inline;
    function Floor: TGVector2; inline;
    function Ceil: TGVector2; inline;

    function ToString: String; inline;

    function Rotate(Angel: Single): TGVector2;

    constructor Create(X, Y: Single);

    class function VecXY(A: TGVector3); static;
    class function VecYX(A: TGVector3); static;
    class function VecYZ(A: TGVector3); static;
    class function VecZY(A: TGVector3); static;
    class function VecZX(A: TGVector3); static;
    class function VecXZ(A: TGVector3); static;

    property S: Single read X write X;
    property T: Single read Y write Y;

  end;

  TTexCoord2 = TGVector2;
  TTexCoord3 = TGVector3;
  TTexCoord4 = TGVector4;

  { TGLocation}
  //TODO: class operator with vector for translation
  TGLocation = record
  private
    FPos: TGvector3;
    FPitch: Single;
    FTurn: Single;
    FRoll: Single;

    FMatrix: TMatrix4;
    FChanged: Boolean;
    FFreeChanged: Boolean;
    FInverted: Boolean;

    function GetLook: TGVector3;
    function GetMatrix: TMatrix4;
    function GetRight: TGVector3;
    function GetUp: TGVector3;

    procedure BuildMatrix;
    procedure SetInverted(AValue: Boolean);
    procedure SetPitch(AValue: Single);
    procedure SetPos(AValue: TGVector3);
    procedure SetRoll(AValue: Single);
    procedure SetTurn(AValue: Single);

  public
    property Matrix: TMatrix4 read GetMatrix;

    function Changed: Boolean;

    property Pos: TGVector3 read FPos write SetPos;
    property Inverted: Boolean read FInverted write SetInverted;

    property TurnAngle: Single read FTurn write SetTurn;
    property PitchAngle: Single read FPitch write SetPitch;
    property RollAngle: Single read FRoll write SetRoll;

    property Right: TGVector3 read GetRight;
    property Up: TGVector3 read GetUp;
    property Look: TGVector3 read GetLook;

    // All of the following functions will trigger the rebuild once the Matrix is requested
    procedure Reset;
    procedure ResetRotation;
    procedure ResetTranslation;
    procedure Turn(ATurn: Single);
    procedure Pitch(APitch: Single);
    procedure Roll(ARoll: Single);
    procedure Translate(AVector: TGVector3);

    // Those will directly change the current Matrix and thus not trigger the rebuild
    procedure Rotate(AVector: TGVector3; AAngle: Single);
    procedure FreeTurn(ATurn: Single);
    procedure FreePitch(APitch: Single);
    procedure FreeRoll(ARoll: Single);
    procedure FreeTranslate(AVector: TGVector3);
  end;

  { TGDirection }

  TGDirection = record
  public
    T, P: Single;

    function ToVector: TGVector; overload;
    function ToVector(Scale: Single): TGVector; overload;
    function ToVector(Scale: TGVector): TGVector; overload;

    function Turn(Angel: Single): TGDirection;
    function Pitch(Angel: Single): TGDirection;
    function TurnPitch(TAngel, PAngel: Single): TGDirection;

    constructor Create(T, P: Single);
    constructor PointDir(Point: TGVector);
  end;

  { TGLine }

  TGLine = record
  public
    type
      TOrthoProjData = record
        Distance: Single;
        Height: Single;
        Point: TGVector3;
      end;
  public
    SV, DV: TGVector;

    function GetPoint(Distance: Single): TGVector; inline;
    function Head: TGVector; inline;
    function Tail: TGVector; inline;

    function OrthoProj(A: TGVector): Boolean; overload;
    function OrthoProj(A: TGVector; out AData: TOrthoProjData): Boolean; overload;

    function Intsec(A: TGLine): Boolean; overload;
    function Intsec(A: TGLine; out S: Single): Boolean; overload;
    function LineIntsec(A: TGLine; out P: TGVector): Boolean; overload;

    constructor Create(SV, DV: TGVector);
  end;

  { TGPlane }

  TGPlane = record
  private
    procedure FillM4x3LineIntsec(const A: TGLine); inline;
  public
    type
      TLineIntsecData = record
        Distance: Single;
        PlaneCoord: TGVector2;
        Point: TGVector3;
      end;

      TOrthoProjData = record
        Height: Single;
        PlaneCoord: TGVector2;
        Point: TGVector3;
      end;

  public
    SV, DVS, DVT: TGVector;

    function LineIntsec(A: TGLine): Boolean; overload; inline;
    function LineIntsec(A: TGLine; out AData: TLineIntsecData): Boolean; overload;

    procedure OrthoProj(A: TGVector; out AData: TOrthoProjData); inline;

    function LineInQuad(A: TGLine; out AData: TLineIntsecData; ACheckScale: Single = 1): Boolean;
    function LineInTri(A: TGLine; out AData: TLineIntsecData; ACheckScale: Single = 1): Boolean;

    function Normal: TGVector3; inline;

    function GetPoint(V: TGVector2): TGVector; overload; inline;
    function GetPoint(S, T: Single): TGVector; overload; inline;
    function GetParaPoint: TGVector; inline;

    function GetAreaTri: Single; inline;
    function GetAreaQuad: Single; inline;

    constructor Create(SV, DVS, DVT: TGVector);
  end;

  { TGEllipse }

  TGEllipse = record
  private
    FDVS, FDVT: TGVector;
    procedure SetDVS(const Value: TGVector);
    procedure SetDVT(const Value: TGVector);
  public
    SV: TGVector;
    property DVS: TGVector read FDVS write SetDVS;
    property DVT: TGVector read FDVT write SetDVT;

    function GetPoint(S: Single): TGVector;

    class function NewS(SV, DVS, DVT: TGVector): TGEllipse; static;
    class function NewT(SV, DVS, DVT: TGVector): TGEllipse; static;
  end;

  { TGSphere }

  TGSphere = record
    SV: TGVector;
    Scale: TGVector;

    function LineIntsec(ALine: TGLine): Boolean; overload;
    function LineIntsec(ALine: TGLine; out P1, P2: TGVector): Boolean; overload;

    function GetPoint(D: TGDirection): TGVector;

    constructor Create(SV, Scale: TGVector);
  end;

  // Pointer
  PGVector = ^TGVector;
  PGVector4 = ^TGVector4;
  PGVector3 = ^TGVector3;
  PGVector2 = ^TGVector2;

  TQuadSide = 0 .. 5;
  TTriangleSide = 0 .. 2;

  TGVectors2 = array of TGVector2;
  TGVectors3 = array of TGVector3;
  TGVectors4 = array of TGVector4;
  TGVectors = TGVectors4;
  TGLines = array of TGLine;
  TGPlanes = array of TGPlane;

const
  Origin:  TGVector4 = (X: 0; Y: 0; Z: 0; W: 1);
  UVecX:   TGVector4 = (X: 1; Y: 0; Z: 0; W: 1);
  UVecY:   TGVector4 = (X: 0; Y: 1; Z: 0; W: 1);
  UVecZ:   TGVector4 = (X: 0; Y: 0; Z: 1; W: 1);
  UVecXY:  TGVector4 = (X: 1; Y: 1; Z: 0; W: 1);
  UVecYZ:  TGVector4 = (X: 0; Y: 1; Z: 1; W: 1);
  UVecXZ:  TGVector4 = (X: 1; Y: 0; Z: 1; W: 1);
  UVecXYZ: TGVector4 = (X: 1; Y: 1; Z: 1; W: 1);

  VecDir: array [TGBasicDir] of TGVector = (
    (X: +1; Y:  0; Z:  0; W: 0),
    (X: -1; Y:  0; Z:  0; W: 0),
    (X:  0; Y: +1; Z:  0; W: 0),
    (X:  0; Y: -1; Z:  0; W: 0),
    (X:  0; Y:  0; Z: +1; W: 0),
    (X:  0; Y:  0; Z: -1; W: 0));

  QuadSideCount = High(TQuadSide) + 1;

  QuadTexCoords: array [TQuadSide] of TTexCoord2 = (
    (X: 0; Y: 0),
    (X: 1; Y: 0),
    (X: 1; Y: 1),
    (X: 1; Y: 1),
    (X: 0; Y: 1),
    (X: 0; Y: 0)
  );
  QuadMiddleCoords: array [TQuadSide] of TTexCoord2 = (
    (X: -1; Y: -1),
    (X: +1; Y: -1),
    (X: +1; Y: +1),
    (X: +1; Y: +1),
    (X: -1; Y: +1),
    (X: -1; Y: -1)
  );
  TriangleTexCoords: array [TTriangleSide] of TTexCoord2 = (
    (X: 0; Y: 0),
    (X: 1; Y: 0),
    (X: 0; Y: 1)
  );


implementation

const
  MinRotation = -180;
  MaxRotation = 180;

{ TGLocation }



function TGLocation.GetLook: TGVector3;
begin
  if FChanged then
    BuildMatrix;
  Result := TGVector3.Create(
    -FMatrix[0, 2],
    -FMatrix[1, 2],
    -FMatrix[2, 2]
  );
end;

function TGLocation.GetMatrix: TMatrix4;
begin
  if FChanged then
    BuildMatrix;
  Result := FMatrix;
end;

function TGLocation.GetRight: TGVector3;
begin
  if FChanged then
    BuildMatrix;
  Result := TGVector3.Create(
    FMatrix[0, 0],
    FMatrix[1, 0],
    FMatrix[2, 0]
  ).Normalize;
end;

function TGLocation.GetUp: TGVector3;
begin
  if FChanged then
    BuildMatrix;
  Result := TGVector3.Create(
    FMatrix[0, 1],
    FMatrix[1, 1],
    FMatrix[2, 1]
  ).Normalize;
end;

procedure TGLocation.BuildMatrix;
begin
  Reset;
  if FInverted then
  begin
    FreeRoll(-FRoll);
    FreePitch(-FPitch);
    FreeTurn(-FTurn);
    FreeTranslate(-FPos);
  end
  else
  begin
    FreeRoll(FRoll);
    FreePitch(FPitch);
    FreeTurn(FTurn);
    FreeTranslate(FPos);
  end;
  FChanged := False;
end;

procedure TGLocation.SetInverted(AValue: Boolean);
begin
  if FInverted = AValue then
    Exit;
  FInverted := AValue;
  FChanged := True;
end;

procedure TGLocation.SetPitch(AValue: Single);
begin
  if FPitch = AValue then
    Exit;
  FPitch := RealMod(AValue, MinRotation, MaxRotation);
  FChanged := True;
end;

procedure TGLocation.SetPos(AValue: TGVector3);
begin
  if FPos = AValue then
    Exit;
  FPos := AValue;
  FChanged := True;
end;

procedure TGLocation.SetRoll(AValue: Single);
begin
  if FRoll = AValue then
    Exit;
  FRoll := RealMod(AValue, MinRotation, MaxRotation);
  FChanged := True;
end;

procedure TGLocation.SetTurn(AValue: Single);
begin
  if FTurn = AValue then
    Exit;
  FTurn := RealMod(AValue, MinRotation, MaxRotation);
  FChanged := True;
end;

function TGLocation.Changed: Boolean;
begin
  Result := FChanged or FFreeChanged;
  FFreeChanged := False;
end;

procedure TGLocation.Reset;
begin
  FMatrix.LoadIdentity;
  FChanged := True;
end;

procedure TGLocation.ResetRotation;
begin
  FTurn := 0;
  FPitch := 0;
  FRoll := 0;
  FChanged := True;
end;

procedure TGLocation.ResetTranslation;
begin
  Pos := Origin;
  FChanged := True;
end;

procedure TGLocation.Turn(ATurn: Single);
begin
  TurnAngle := FTurn + ATurn;
  FChanged := True;
end;

procedure TGLocation.Pitch(APitch: Single);
begin
  PitchAngle := FPitch + APitch;
  FChanged := True;
end;

procedure TGLocation.Roll(ARoll: Single);
begin
  RollAngle := FRoll + ARoll;
  FChanged := True;
end;

procedure TGLocation.FreeTurn(ATurn: Single);
var
  M: TMatrix4;
begin
  ATurn := ATurn * Pi / 180;
  M.LoadIdentity;
  M[0, 0] :=  cos(ATurn);
  M[2, 0] :=  sin(ATurn);
  M[0, 2] := -sin(ATurn);
  M[2, 2] :=  cos(ATurn);
  FMatrix := FMatrix * M;
  FFreeChanged := True;
end;

procedure TGLocation.FreePitch(APitch: Single);
var
  M: TMatrix4;
begin
  APitch := APitch * Pi / 180;
  M.LoadIdentity;
  M[1, 1] :=  cos(APitch);
  M[2, 1] := -sin(APitch);
  M[1, 2] :=  sin(APitch);
  M[2, 2] :=  cos(APitch);
  FMatrix := FMatrix * M;
  FFreeChanged := True;
end;

procedure TGLocation.FreeRoll(ARoll: Single);
var
  M: TMatrix4;
begin
  ARoll := ARoll * Pi / 180;
  M.LoadIdentity;
  M[0, 0] :=  cos(ARoll);
  M[1, 0] := -sin(ARoll);
  M[0, 1] :=  sin(ARoll);
  M[1, 1] :=  cos(ARoll);
  FMatrix := FMatrix * M;
  FFreeChanged := True;
end;

procedure TGLocation.FreeTranslate(AVector: TGVector3);
var
  M: TMatrix4;
begin
  M.LoadIdentity;
  M[3, 0] := AVector.X;
  M[3, 1] := AVector.Y;
  M[3, 2] := AVector.Z;
  FMatrix := FMatrix * M;
  FFreeChanged := True;
end;

procedure TGLocation.Translate(AVector: TGVector3);
begin
  FPos := FPos + AVector;
  FChanged := True;
end;

procedure TGLocation.Rotate(AVector: TGVector3; AAngle: Single);
var
  S, C, CInv: Single;
  M: TMatrix4;
begin
  AVector := AVector.Normalize;

  S := Sin(AAngle / 180 * Pi);
  C := Cos(AAngle / 180 * Pi);
  CInv := 1 - C;

  M.Clear;
  // right
  M[0, 0] := AVector.X * AVector.X * CInv + C;
  M[0, 1] := AVector.Y * AVector.X * CInv + AVector.Z * S;
  M[0, 2] := AVector.Z * AVector.X * CInv - AVector.Y * S;
  // up
  M[1, 0] := AVector.X * AVector.Y * CInv - AVector.Z * S;
  M[1, 1] := AVector.Y * AVector.Y * CInv + C;
  M[1, 2] := AVector.Z * AVector.Y * CInv + AVector.X * S;
  // look
  M[2, 0] := AVector.X * AVector.Z * CInv + AVector.Y * S;
  M[2, 1] := AVector.Y * AVector.Z * CInv - AVector.X * S;
  M[2, 2] := AVector.Z * AVector.Z * CInv + C;

  M[3, 3] := 1;

  FMatrix := FMatrix * M;

  FFreeChanged := True;
end;

{ TGVector2 }

class operator TGVector2.Add(A, B: TGVector2): TGVector2;
begin
  Result.X := A.X + B.X;
  Result.Y := A.Y + B.Y;
end;

class operator TGVector2.Subtract(A, B: TGVector2): TGVector2;
begin
  Result.X := A.X - B.X;
  Result.Y := A.Y - B.Y;
end;

class operator TGVector2.Add(A: TGVector2; V: Single): TGVector2;
begin
  Result.X := A.X + V;
  Result.Y := A.Y + V;
end;

class operator TGVector2.Subtract(A: TGVector2; V: Single): TGVector2;
begin
  Result.X := A.X - V;
  Result.Y := A.Y - V;
end;

class operator TGVector2.Multiply(V: Single; A: TGVector2): TGVector2;
begin
  Result.X := V * A.X;
  Result.Y := V * A.Y;
end;

class operator TGVector2.Multiply(A: TGVector2; V: Single): TGVector2;
begin
  Result.X := V * A.X;
  Result.Y := V * A.Y;
end;

class operator TGVector2.Multiply(A, B: TGVector2): TGVector2;
begin
  Result.X := A.X * B.X;
  Result.Y := A.Y * B.Y;
end;

class operator TGVector2.Divide(V: Single; A: TGVector2): TGVector2;
begin
  Result.X := V / A.X;
  Result.Y := V / A.Y;
end;

class operator TGVector2.Divide(A: TGVector2; V: Single): TGVector2;
begin
  Result.X := A.X / V;
  Result.Y := A.Y / V;
end;

class operator TGVector2.Negative(A: TGVector2): TGVector2;
begin
  Result.X := -A.X;
  Result.Y := -A.Y;
end;

class operator TGVector2.Equal(A, B: TGVector2): Boolean;
begin
  Result := (A.X = B.X) and (A.Y = B.Y);
end;

class operator TGVector2.NotEqual(A, B: TGVector2): Boolean;
begin
  Result := (A.X <> B.X) or (A.Y <> B.Y);
end;

class operator TGVector2.LessThan(A, B: TGVector2): Boolean;
begin
  Result := (A.X < B.X) and (A.Y < B.Y);
end;

class operator TGVector2.LessThanOrEqual(A, B: TGVector2): Boolean;
begin
  Result := (A.X <= B.X) and (A.Y <= B.Y);
end;

class operator TGVector2.GreaterThan(A, B: TGVector2): Boolean;
begin
  Result := (A.X > B.X) and (A.Y > B.Y);
end;

class operator TGVector2.GreaterThanOrEqual(A, B: TGVector2): Boolean;
begin
  Result := (A.X >= B.X) and (A.Y >= B.Y);
end;

class operator TGVector2.Implicit(A: TGVector3): TGVector2;
begin
  Result.X := A.X;
  Result.Y := A.Y;
end;

class operator TGVector2.Implicit(A: TGVector4): TGVector2;
begin
  Result.X := A.X;
  Result.Y := A.Y;
end;

class operator TGVector2.Implicit(A: TGVector2): TGVector4;
begin
  Result.X := A.X;
  Result.Y := A.Y;
  Result.Z := 0;
  Result.W := 1;
end;

class operator TGVector2.Implicit(A: TGVector2): TGVector3;
begin
  Result.X := A.X;
  Result.Y := A.Y;
  Result.Z := 0;
end;

class operator TGVector2.Implicit(A: TGVector2): String;
begin
  Result := Format('[%f|%f]', [A.X, A.Y]);
end;

function TGVector2.ToVec3(Z: Single): TGVector3;
begin
  Result.X := X;
  Result.Y := Y;
  Result.Z := Z;
end;

function TGVector2.ToVec4(Z: Single; W: Single): TGVector4;
begin
  Result.X := X;
  Result.Y := Y;
  Result.Z := Z;
  Result.W := W;
end;

function TGVector2.Cross: TGVector2;
begin
  Result.X := -Y;
  Result.Y := X;
end;

function TGVector2.Dot(A: TGVector2): Single;
begin
  Result := X * A.X + Y * A.Y;
end;

function TGVector2.SqrDot: Single;
begin
  Result := Sqr(X) + Sqr(Y);
end;

function TGVector2.Length: Single;
begin
  Result := Sqrt(SqrDot);
end;

function TGVector2.DistanceTo(A: TGVector2): Single;
begin
  Result := VectorTo(A).Length;
end;

function TGVector2.VectorTo(A: TGVector2): TGVector2;
begin
  Result := A - Self;
end;

function TGVector2.Normalize: TGVector2;
begin
  Result := Self / Length;
end;

function TGVector2.GetAngle(A: TGVector2): Single;
begin
  Result := ArcCos(Dot(A) / (Length * A.Length)) * 180 / Pi;
end;

function TGVector2.Floor: TGVector2;
begin
  Result.X := Math.Floor(X);
  Result.Y := Math.Floor(Y);
end;

function TGVector2.Ceil: TGVector2;
begin
  Result.X := Math.Ceil(X);
  Result.Y := Math.Ceil(Y);
end;

function TGVector2.ToString: String;
begin
  Result := Self;
end;

function TGVector2.Rotate(Angel: Single): TGVector2;
begin
  Angel := Angel * Pi / 180;
  Result := Sin(Angel) * Cross + Cos(Angel) * Self;
end;

constructor TGVector2.Create(X, Y: Single);
begin
  Self.X := X;
  Self.Y := Y;
end;

class function TGVector2.VecXY(A: TGVector3);
begin
  Result.X := A.X;
  Result.Y := A.Y;
end;

class function TGVector2.VecYX(A: TGVector3);
begin
  Result.X := A.Y;
  Result.Y := A.X;
end;

class function TGVector2.VecYZ(A: TGVector3);
begin
  Result.X := A.Y;
  Result.Y := A.Z;
end;

class function TGVector2.VecZY(A: TGVector3);
begin
  Result.X := A.Z;
  Result.Y := A.Y;
end;

class function TGVector2.VecZX(A: TGVector3);
begin
  Result.X := A.Z;
  Result.Y := A.X;
end;

class function TGVector2.VecXZ(A: TGVector3);
begin
  Result.X := A.X;
  Result.Y := A.Z;
end;

{ TGVector3 }

class operator TGVector3.Add(A, B: TGVector3): TGVector3;
begin
  Result.X := A.X + B.X;
  Result.Y := A.Y + B.Y;
  Result.Z := A.Z + B.Z;
end;

class operator TGVector3.Subtract(A, B: TGVector3): TGVector3;
begin
  Result.X := A.X - B.X;
  Result.Y := A.Y - B.Y;
  Result.Z := A.Z - B.Z;
end;

class operator TGVector3.Add(A: TGVector3; V: Single): TGVector3;
begin
  Result.X := A.X + V;
  Result.Y := A.Y + V;
  Result.Z := A.Z + V;
end;

class operator TGVector3.Subtract(A: TGVector3; V: Single): TGVector3;
begin
  Result.X := A.X - V;
  Result.Y := A.Y - V;
  Result.Z := A.Z - V;
end;

class operator TGVector3.Multiply(V: Single; A: TGVector3): TGVector3;
begin
  Result.X := V * A.X;
  Result.Y := V * A.Y;
  Result.Z := V * A.Z;
end;

class operator TGVector3.Multiply(A: TGVector3; V: Single): TGVector3;
begin
  Result.X := A.X * V;
  Result.Y := A.Y * V;
  Result.Z := A.Z * V;
end;

class operator TGVector3.Multiply(A, B: TGVector3): TGVector3;
begin
  Result.X := A.X * B.X;
  Result.Y := A.Y * B.Y;
  Result.Z := A.Z * B.Z;
end;

class operator TGVector3.Divide(V: Single; A: TGVector3): TGVector3;
begin
  Result.X := V / A.X;
  Result.Y := V / A.Y;
  Result.Z := V / A.Z;
end;

class operator TGVector3.Divide(A: TGVector3; V: Single): TGVector3;
begin
  Result.X := A.X / V;
  Result.Y := A.Y / V;
  Result.Z := A.Z / V;
end;

class operator TGVector3.Negative(A: TGVector3): TGVector3;
begin
  Result.X := -A.X;
  Result.Y := -A.Y;
  Result.Z := -A.Z;
end;

class operator TGVector3.Equal(A, B: TGVector3): Boolean;
begin
  Result := (A.X = B.X) and (A.Y = B.Y) and (A.Z = B.Z);
end;

class operator TGVector3.NotEqual(A, B: TGVector3): Boolean;
begin
  Result := (A.X <> B.X) or (A.Y <> B.Y) or (A.Z <> B.Z);
end;

class operator TGVector3.LessThan(A, B: TGVector3): Boolean;
begin
  Result := (A.X < B.X) and (A.Y < B.Y) and (A.Z < B.Z);
end;

class operator TGVector3.LessThanOrEqual(A, B: TGVector3): Boolean;
begin
  Result := (A.X <= B.X) and (A.Y <= B.Y) and (A.Z <= B.Z);
end;

class operator TGVector3.GreaterThan(A, B: TGVector3): Boolean;
begin
  Result := (A.X > B.X) and (A.Y > B.Y) and (A.Z > B.Z);
end;

class operator TGVector3.GreaterThanOrEqual(A, B: TGVector3): Boolean;
begin
  Result := (A.X >= B.X) and (A.Y >= B.Y) and (A.Z >= B.Z);
end;

class operator TGVector3.Implicit(A: TGVector4): TGVector3;
begin
  Result.X := A.X;
  Result.Y := A.Y;
  Result.Z := A.Z;
end;

class operator TGVector3.Implicit(A: TGVector3): TGVector4;
begin
  Result.X := A.X;
  Result.Y := A.Y;
  Result.Z := A.Z;
  Result.W := 1;
end;

class operator TGVector3.Implicit(A: TGVector3): String;
begin
  Result := Format('[%f|%f|%f]', [A.X, A.Y, A.Z]);
end;

function TGVector3.ToVec4(W: Single): TGVector4;
begin
  Result.X := X;
  Result.Y := Y;
  Result.Z := Z;
  Result.W := W;
end;

function TGVector3.Cross(A: TGVector3): TGVector3;
begin
  if (Self = Origin) or (A = Origin) then
    Result := Origin
  else
  begin
    Result.X := Y * A.Z - Z * A.Y;
    Result.Y := Z * A.X - X * A.Z;
    Result.Z := X * A.Y - Y * A.X;
  end;
end;

function TGVector3.Dot(A: TGVector3): Single;
begin
  Result := X * A.X + Y * A.Y + Z * A.Z;
end;

function TGVector3.SqrDot: Single;
begin
  Result := Sqr(X) + Sqr(Y) + Sqr(Z);
end;

function TGVector3.Length: Single;
begin
  Result := Sqrt(SqrDot);
end;

function TGVector3.DistanceTo(A: TGVector3): Single;
begin
  Result := (A - Self).Length;
end;

function TGVector3.VectorTo(A: TGVector3): TGVector3;
begin
  Result := A - Self;
end;

function TGVector3.Normalize: TGVector3;
begin
  Result := Self / Length;
end;

function TGVector3.GetAngel(A: TGVector3): Single;
begin
  Result := ArcCos(Dot(A) / (Length * A.Length)) * 180 / Pi;
end;

function TGVector3.Floor: TGVector3;
begin
  Result.X := Math.Floor(X);
  Result.Y := Math.Floor(Y);
  Result.Z := Math.Floor(Z);
end;

function TGVector3.Ceil: TGVector3;
begin
  Result.X := Math.Ceil(X);
  Result.Y := Math.Ceil(Y);
  Result.Z := Math.Ceil(Z);
end;

function TGVector3.ToString: String;
begin
  Result := Self;
end;

function TGVector3.Rotate(A: TGVector3; Angel: Single): TGVector3;
var
  UX, UZ: TGVector3;
  VX, VY: Single;
begin
  Angel := Angel * Pi / 180;

  A := A.Normalize;

  UZ := Self.Cross(A);
  UX := A.Cross(UZ);

  VX := UX.Dot(Self) / UX.Dot(UX);
  VY := A.Dot(Self) / A.Dot(A);

  Result := Cos(Angel) * VX * UX + VY * A + Sin(Angel) * VX * UZ;
end;

constructor TGVector3.Create(X, Y, Z: Single);
begin
  Self.X := X;
  Self.Y := Y;
  Self.Z := Z;
end;

{ TGLine }

function TGLine.GetPoint(Distance: Single): TGVector;
begin
  Result := Self.SV + Self.DV * Distance;
end;

function TGLine.Head: TGVector;
begin
  Result := SV;
end;

function TGLine.Tail: TGVector;
begin
  Result := SV + DV
end;

function TGLine.LineIntsec(A: TGLine; out P: TGVector): Boolean;
var
  S: Single;
begin
  if Intsec(A, S) then
  begin
    Result := True;
    P := GetPoint(S);
  end
  else
    Result := False;
end;

constructor TGLine.Create(SV, DV: TGVector);
begin
  Self.SV := SV;
  Self.DV := DV;
end;

function TGLine.OrthoProj(A: TGVector): Boolean;
var
  Distance: Single;
begin
  Distance := DV.Dot(A - SV) / DV.SqrDot;
  Result := (Distance >= 0) and (Distance <= 1);
end;

function TGLine.OrthoProj(A: TGVector; out AData: TOrthoProjData): Boolean;
begin
  AData.Distance := DV.Dot(A - SV) / DV.SqrDot;
  AData.Point := GetPoint(AData.Distance);
  AData.Height := (AData.Point - A).Length;
  Result := (AData.Distance >= 0) and (AData.Distance <= 1);
end;

function TGLine.Intsec(A: TGLine): Boolean;
var
  P: array [0 .. 1] of Single;
begin
  // Theorie: Self.SV + S * Self.DV = A.SV + T * A.DV
  // >  S * Self.DV + T * A.DV = A.SV - Self.SV
  M3x2[0, 0] := Self.DV.X;
  M3x2[1, 0] := A.DV.X;
  M3x2[2, 0] := A.SV.X - Self.SV.X;
  M3x2[0, 1] := Self.DV.Y;
  M3x2[1, 1] := A.DV.Y;
  M3x2[2, 1] := A.SV.Y - Self.SV.Y;
  if M3x2.Solve(P) then
    Result := (P[0] * Self.DV.Z + P[1] * A.DV.Z) = (A.SV.Z - Self.SV.Z)
  else
    Result := False;
end;

function TGLine.Intsec(A: TGLine; out S: Single): Boolean;
var
  P: array [0 .. 1] of Single;
begin
  M3x2[0, 0] := Self.DV.X;
  M3x2[1, 0] := A.DV.X;
  M3x2[2, 0] := A.SV.X - Self.SV.X;
  M3x2[0, 1] := Self.DV.Y;
  M3x2[1, 1] := A.DV.Y;
  M3x2[2, 1] := A.SV.Y - Self.SV.Y;
  if M3x2.Solve(P) then
  begin
    Result := (P[0] * Self.DV.Z + P[1] * A.DV.Z) <> (A.SV.Z - Self.SV.Z);
    if Result then
       S := P[0];
  end
  else
    Result := False;
end;

{ TGPlane }

procedure TGPlane.FillM4x3LineIntsec(const A: TGLine);
begin
  // Theorie: Self.SV + S * Self.DVS + T * Self.DVT = A.SV + U * A.DV
  // > S * Self.DVS + T * Self.DVT - U * A.DV = A.SV - Self.SV
  M4x3[0, 0] := Self.DVS.X;
  M4x3[1, 0] := Self.DVT.X;
  M4x3[2, 0] := -A.DV.X;
  M4x3[3, 0] := A.SV.X - Self.SV.X;
  M4x3[0, 1] := Self.DVS.Y;
  M4x3[1, 1] := Self.DVT.Y;
  M4x3[2, 1] := -A.DV.Y;
  M4x3[3, 1] := A.SV.Y - Self.SV.Y;
  M4x3[0, 2] := Self.DVS.Z;
  M4x3[1, 2] := Self.DVT.Z;
  M4x3[2, 2] := -A.DV.Z;
  M4x3[3, 2] := A.SV.Z - Self.SV.Z;
end;

function TGPlane.LineIntsec(A: TGLine): Boolean;
begin
  FillM4x3LineIntsec(A);
  Result := M4x3.Solveable;
end;

function TGPlane.LineIntsec(A: TGLine; out AData: TLineIntsecData): Boolean;
var
  R: array [0 .. 2] of Single;
begin
  FillM4x3LineIntsec(A);
  Result := M4x3.Solve(R);
  AData.Distance := R[2];
  AData.PlaneCoord := TGVector2.Create(R[0], R[1]);
  AData.Point := GetPoint(R[0], R[1]);
end;

procedure TGPlane.OrthoProj(A: TGVector; out AData: TOrthoProjData);
begin
  // yes, this is probably the fastest i can get :)
  AData.PlaneCoord.X := (DVT.SqrDot * DVS.Dot(A - SV) - DVT.Dot(DVS) * DVT.Dot(A - SV)) /
                        (DVS.SqrDot * DVT.SqrDot - Sqr(DVS.Dot(DVT)));
  AData.PlaneCoord.Y := (DVS.SqrDot * DVT.Dot(A - SV) - DVS.Dot(DVT) * DVS.Dot(A - SV)) /
                        (DVT.SqrDot * DVS.SqrDot - Sqr(DVT.Dot(DVS)));
  AData.Point := GetPoint(AData.PlaneCoord);
  AData.Height := (AData.Point - A).Length;
end;

function TGPlane.GetAreaQuad: Single;
begin
  Result := DVS.Cross(DVT).Length;
end;

function TGPlane.GetAreaTri: Single;
begin
  Result := DVS.Cross(DVT).Length / 2;
end;

function TGPlane.GetParaPoint: TGVector;
begin
  Result := GetPoint(1, 1);
end;

function TGPlane.GetPoint(V: TGVector2): TGVector;
begin
  Result := SV + V.X * DVS + V.Y * DVT;
end;

function TGPlane.GetPoint(S, T: Single): TGVector;
begin
  Result := SV + S * DVS + T * DVT;
end;

function TGPlane.LineInQuad(A: TGLine; out AData: TLineIntsecData; ACheckScale: Single): Boolean;
begin
  Result := LineIntsec(A, AData);
  if not Result then
    Exit;
  if ACheckScale <> 1 then
    AData.PlaneCoord := (AData.PlaneCoord - 0.5) / ACheckScale + 0.5;
  Result := (AData.PlaneCoord.X >= 0) and
            (AData.PlaneCoord.X <= 1) and
            (AData.PlaneCoord.Y >= 0) and
            (AData.PlaneCoord.Y <= 1);
end;

function TGPlane.LineInTri(A: TGLine; out AData: TLineIntsecData; ACheckScale: Single): Boolean;
begin
  Result := LineIntsec(A, AData);
  if not Result then
    Exit;
  if ACheckScale <> 1 then
    AData.PlaneCoord := (AData.PlaneCoord - 0.5) / ACheckScale + 0.5;
  Result := (AData.PlaneCoord.X >= 0) and
            (AData.PlaneCoord.Y >= 0) and
            (AData.PlaneCoord.X + AData.PlaneCoord.Y <= 1);
end;

constructor TGPlane.Create(SV, DVS, DVT: TGVector);
begin
  Self.SV := SV;
  Self.DVS := DVS;
  Self.DVT := DVT;
end;

function TGPlane.Normal: TGVector3;
begin
  Result := DVS.Cross(DVT).Normalize;
end;

{ TGSphere }

function TGSphere.GetPoint(D: TGDirection): TGVector;
begin
  Result := SV + D.ToVector(Scale);
end;

function TGSphere.LineIntsec(ALine: TGLine): Boolean;
var
  Data: TGLine.TOrthoProjData;
begin
  ALine.SV := ALine.SV / Scale;
  ALine.DV := ALine.DV * Scale;
  ALine.OrthoProj(SV / Scale, Data);
  Result := Data.Height <= 1;
end;

function TGSphere.LineIntsec(ALine: TGLine; out P1, P2: TGVector): Boolean;
var
  Dis: Single;
  Data: TGLine.TOrthoProjData;
begin
  ALine.SV := ALine.SV / Scale;
  ALine.DV := ALine.DV / Scale;
  ALine.OrthoProj(SV / Scale, Data);
  Dis := Data.Height;
  P1 := Data.Point;
  if Dis > 1 then
    Result := False
  else
  begin
    P2 := (P1 - ALine.DV.Normalize * sqrt(1 - Dis * Dis)) * Scale;
    P1 := (P1 + ALine.DV.Normalize * sqrt(1 - Dis * Dis)) * Scale;
    Result := True;
  end;
end;

constructor TGSphere.Create(SV, Scale: TGVector);
begin
  Self.SV := SV;
  Self.Scale := Scale;
end;

{ TGEllipse }

function TGEllipse.GetPoint(S: Single): TGVector;
begin
  Result := SV + Sin(S) * DVS + Cos(S) * DVT;
end;

class function TGEllipse.NewS(SV, DVS, DVT: TGVector): TGEllipse;
begin
  Result.SV := SV;
  Result.FDVT := DVT;
  Result.DVS := DVS;
end;

class function TGEllipse.NewT(SV, DVS, DVT: TGVector): TGEllipse;
begin
  Result.SV := SV;
  Result.FDVS := DVS;
  Result.DVT := DVT;
end;

procedure TGEllipse.SetDVS(const Value: TGVector);
var
  N: TGVector;
begin
  FDVS := Value;
  N := DVS.Cross(DVT);
  FDVT := N.Cross(DVS) / DVS.Dot(DVS);
end;

procedure TGEllipse.SetDVT(const Value: TGVector);
var
  N: TGVector;
begin
  FDVT := Value;
  N := DVT.Cross(DVS);
  FDVS := N.Cross(DVT) / DVT.Dot(DVT);
end;

{ TGDirection }

function TGDirection.ToVector: TGVector;
begin
  Result := TGVector.Create(Sin(T) * Cos(P / 2), Sin(P / 2), Cos(T) * Cos(P / 2), 0);
end;

constructor TGDirection.Create(T, P: Single);
begin
  Self.T := T / 180 * Pi;
  Self.P := P / 180 * Pi;
end;

function TGDirection.Pitch(Angel: Single): TGDirection;
begin
  Result.T := T;
  Result.P := P + Angel / 180 * Pi;
end;

constructor TGDirection.PointDir(Point: TGVector);
var
  T: Single;
begin
  Point := Point.Normalize;
  Self.P := -ArcSin(Point.Y);
  T := Point.X / Sqrt(1 - sqr(Point.Y));
  Self.T := ArcSin(T);
  if Point.Z > 0 then
    Self.T := Pi - Self.T;
end;

function TGDirection.ToVector(Scale: Single): TGVector;
begin
  Result := TGVector.Create(Sin(T) * Cos(P), Sin(P), Cos(T) * Cos(P), 0) * Scale;
end;

function TGDirection.ToVector(Scale: TGVector): TGVector;
begin
  Result := TGVector.Create(Sin(T) * Cos(P / 2), Sin(P / 2), Cos(T) * Cos(P / 2), 0) * Scale;
end;

function TGDirection.Turn(Angel: Single): TGDirection;
begin
  Result.T := T + Angel / 180 * Pi;
  Result.P := P;
end;

function TGDirection.TurnPitch(TAngel, PAngel: Single): TGDirection;
begin
  Result.T := T + TAngel / 180 * Pi;
  Result.P := P + PAngel / 180 * Pi;
end;

{ TGVector }

class operator TGVector.Add(A, B: TGVector): TGVector;
begin
  Result.X := A.X + B.X;
  Result.Y := A.Y + B.Y;
  Result.Z := A.Z + B.Z;
  Result.W := A.W;
end;

function TGVector.Cross(A: TGVector): TGVector;
begin
  if (Self = Origin) or (A = Origin) then
    Result := Origin
  else
  begin
    Result.X := Y * A.Z - Z * A.Y;
    Result.Y := Z * A.X - X * A.Z;
    Result.Z := X * A.Y - Y * A.X;
    Result.W := Self.W;
  end;
end;

function TGVector.DistanceTo(A: TGVector): Single;
begin
  Result := VectorTo(A).Length;
end;

class operator TGVector.Divide(A: TGVector; V: Single): TGVector;
begin
  Result.X := A.X / V;
  Result.Y := A.Y / V;
  Result.Z := A.Z / V;
  Result.W := A.W;
end;

class operator TGVector.Divide(V: Single; A: TGVector): TGVector;
begin
  Result.X := V / A.X;
  Result.Y := V / A.Y;
  Result.Z := V / A.Z;
  Result.W := A.W;
end;

class operator TGVector.Divide(A, B: TGVector): TGVector;
begin
  Result.X := A.X / B.X;
  Result.Y := A.Y / B.Y;
  Result.Z := A.Z / B.Z;
  Result.W := A.W;
end;

function TGVector.Dot(A: TGVector): Single;
begin
  Result := X * A.X + Y * A.Y + Z * A.Z;
end;

class operator TGVector.Equal(A, B: TGVector): Boolean;
begin
  Result := (A.X = B.X) and (A.Y = B.Y) and (A.Z = B.Z);
end;

function TGVector.VectorTo(A: TGVector): TGVector;
begin
  Result := A - Self;
end;

function TGVector.Length: Single;
begin
  Result := Sqrt(SqrDot);
end;

class operator TGVector.Multiply(A, B: TGVector): TGVector;
begin
  Result.X := A.X * B.X;
  Result.Y := A.Y * B.Y;
  Result.Z := A.Z * B.Z;
  Result.W := A.W;
end;

class operator TGVector.Multiply(A: TMatrix4; B: TGVector): TGVector;
begin
  Result.X := A[0, 0] * B.X + A[0, 1] * B.Y + A[0, 2] * B.Z + A[0, 3] * B.W;
  Result.Y := A[1, 0] * B.X + A[1, 1] * B.Y + A[1, 2] * B.Z + A[1, 3] * B.W;
  Result.Z := A[2, 0] * B.X + A[2, 1] * B.Y + A[2, 2] * B.Z + A[2, 3] * B.W;
  Result.W := A[3, 0] * B.X + A[3, 1] * B.Y + A[3, 2] * B.Z + A[3, 3] * B.W;
end;

class operator TGVector.Multiply(A: TGVector; V: Single): TGVector;
begin
  Result.X := A.X * V;
  Result.Y := A.Y * V;
  Result.Z := A.Z * V;
  Result.W := A.W;
end;

class operator TGVector.Multiply(V: Single; A: TGVector): TGVector;
begin
  Result := A * V;
end;

class operator TGVector.Negative(A: TGVector): TGVector;
begin
  Result.X := -A.X;
  Result.Y := -A.Y;
  Result.Z := -A.Z;
  Result.W := A.W;
end;

constructor TGVector.Create(X, Y, Z : Single; W : Single);
begin
  Self.X := X;
  Self.Y := Y;
  Self.Z := Z;
  Self.W := W;
end;

function TGVector.Normalize: TGVector;
begin
  Result := Self / Self.Length;
end;

function TGVector.GetAngel(A: TGVector): Single;
begin
  Result := ArcCos(Dot(A) / (Length * A.Length)) * 180 / Pi;
end;

function TGVector.Floor: TGVector;
begin
  Result.X := Math.Floor(X);
  Result.Y := Math.Floor(Y);
  Result.Z := Math.Floor(Z);
end;

function TGVector.Ceil: TGVector;
begin
  Result.X := Math.Ceil(X);
  Result.Y := Math.Ceil(Y);
  Result.Z := Math.Ceil(Z);
end;

function TGVector.ToString: String;
begin
  Result := Self;
end;

class operator TGVector.NotEqual(A, B: TGVector): Boolean;
begin
  Result := (A.X <> B.X) or (A.Y <> B.Y) or (A.Z <> B.Z);
end;

class operator TGVector.LessThan(A, B : TGVector) : Boolean;
begin
  Result := (A.X < B.X) and (A.Y < B.Y) and (A.Z < B.Z);
end;

class operator TGVector.LessThanOrEqual(A, B : TGVector) : Boolean;
begin
  Result := (A.X <= B.X) and (A.Y <= B.Y) and (A.Z <= B.Z);
end;

class operator TGVector.GreaterThan(A, B: TGVector): Boolean;
begin
  Result := (A.X > B.X) and (A.Y > B.Y) and (A.Z > B.Z);
end;

class operator TGVector.GreaterThanOrEqual(A, B: TGVector): Boolean;
begin
  Result := (A.X >= B.X) and (A.Y >= B.Y) and (A.Z >= B.Z);
end;

class operator TGVector.Implicit(A: TGVector): String;
begin
  Result := Format('[%f|%f|%f]', [A.X, A.Y, A.Z]);
end;

function TGVector.Rotate(A: TGVector; Angel: Single): TGVector;
var
  UX, UZ: TGVector;
  VX, VY: Single;
begin
  Angel := Angel * Pi / 180;

  A := A.Normalize;

  UZ := Self.Cross(A);
  UX := A.Cross(UZ);

  VX := UX.Dot(Self) / UX.Dot(UX);
  VY := A.Dot(Self) / A.Dot(A);

  Result := Cos(Angel) * VX * UX + VY * A + Sin(Angel) * VX * UZ;
end;

class operator TGVector.Subtract(A, B: TGVector): TGVector;
begin
  Result.X := A.X - B.X;
  Result.Y := A.Y - B.Y;
  Result.Z := A.Z - B.Z;
  Result.W := A.W;
end;

class operator TGVector.Add(A: TGVector; V: Single): TGVector;
begin
  Result.X := A.X + V;
  Result.Y := A.Y + V;
  Result.Z := A.Z + V;
  Result.W := A.W;
end;

class operator TGVector.Subtract(A: TGVector; V: Single): TGVector;
begin
  Result.X := A.X - V;
  Result.Y := A.Y - V;
  Result.Z := A.Z - V;
  Result.W := A.W;
end;

function TGVector.SqrDot: Single;
begin
  Result := sqr(X) + sqr(Y) + sqr(Z);
end;

end.
