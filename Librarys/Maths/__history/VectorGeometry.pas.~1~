unit VectorGeometry;

{$IFDEF FPC}
{$mode Delphi}
{$ENDIF}

interface

uses
  Matrix, SysUtils, dglOpenGL, Math;

type
  TSingleArray = array of Single;

  TGBasicDir = (sdRight, sdLeft, sdUp, sdDown, sdFront, sdBack);

  { TGVector }

  TGVector = record
    X, Y, Z, W: Single;

    class operator Add(A, B: TGVector): TGVector;

    class operator Subtract(A, B: TGVector): TGVector;

    class operator Multiply(A: TGVector; V: Single): TGVector;
    class operator Multiply(V: Single; A: TGVector): TGVector;
    class operator Multiply(A, B: TGVector): TGVector;

    class operator Divide(A: TGVector; V: Single): TGVector;
    class operator Divide(V: Single; A: TGVector): TGVector;
    class operator Divide(A, B: TGVector): TGVector;

    class operator Negative(A: TGVector): TGVector;

    class operator Equal(A, B: TGVector): Boolean;
    class operator NotEqual(A, B: TGVector): Boolean;
    class operator LessThan(A, B: TGVector): Boolean;
    class operator LessThanOrEqual(A, B: TGVector): Boolean;
    class operator GreaterThan(A, B: TGVector): Boolean;
    class operator GreaterThanOrEqual(A, B: TGVector): Boolean;

    function Cross(A: TGVector): TGVector; inline;
    function Dot(A: TGVector): Single; inline;
    function SqrDot: Single; inline;
    function Length: Single; inline;
    function DistanceTo(A: TGVector): Single; inline;
    function VectorTo(A: TGVector): TGVector; inline;
    function Normalize: TGVector; inline;
    function GetAngel(A: TGVector): Single; inline;

    function Rotate(A: TGVector; Angel: Single): TGVector;

    class function New(X, Y, Z: Single; W: Single = 1): TGVector; static;
  end;

  TGVector4 = TGVector;

  { TGVector3 }

  TGVector3 = record
    X, Y, Z: Single;

    class operator Add(A, B: TGVector3): TGVector3;
    class operator Subtract(A, B: TGVector3): TGVector3;

    class operator Multiply(V: Single; A: TGVector3): TGVector3;
    class operator Multiply(A: TGVector3; V: Single): TGVector3;
    class operator Multiply(A, B: TGVector): TGVector3;

    class operator Divide(V: Single; A: TGVector3): TGVector3;
    class operator Divide(A: TGVector3; V: Single): TGVector3;

    class operator Negative(A: TGVector3): TGVector3;

    class operator Equal(A, B: TGVector3): Boolean;
    class operator NotEqual(A, B: TGVector3): Boolean;
    class operator LessThan(A, B: TGVector3): Boolean;
    class operator LessThanOrEqual(A, B: TGVector3): Boolean;
    class operator GreaterThan(A, B: TGVector3): Boolean;
    class operator GreaterThanOrEqual(A, B: TGVector3): Boolean;

    class operator Implicit(A: TGVector): TGVector3;
    function ToVec4(W: Single = 1): TGVector4;

    function Cross(A: TGVector3): TGVector3; inline;
    function Dot(A: TGVector3): Single; inline;
    function SqrDot: Single; inline;
    function Length: Single; inline;
    function DistanceTo(A: TGVector3): Single; inline;
    function VectorTo(A: TGVector3): TGVector3; inline;
    function Normalize: TGVector3; inline;
    function GetAngel(A: TGVector3): Single; inline;

    function Rotate(A: TGVector3; Angel: Single): TGVector3;

    class function New(X, Y, Z: Single): TGVector3; static;
  end;

  { TGVector2 }

  TGVector2 = record
    X, Y: Single;

    class operator Add(A, B: TGVector2): TGVector2;
    class operator Subtract(A, B: TGVector2): TGVector2;

    class operator Multiply(V: Single; A: TGVector2): TGVector2;
    class operator Multiply(A: TGVector2; V: Single): TGVector2;
    class operator Multiply(A, B: TGVector): TGVector2;

    class operator Divide(V: Single; A: TGVector2): TGVector2;
    class operator Divide(A: TGVector2; V: Single): TGVector2;

    class operator Negative(A: TGVector2): TGVector2;

    class operator Equal(A, B: TGVector2): Boolean;
    class operator NotEqual(A, B: TGVector2): Boolean;
    class operator LessThan(A, B: TGVector2): Boolean;
    class operator LessThanOrEqual(A, B: TGVector2): Boolean;
    class operator GreaterThan(A, B: TGVector2): Boolean;
    class operator GreaterThanOrEqual(A, B: TGVector2): Boolean;

    class operator Implicit(A: TGVector3): TGVector2;
    class operator Implicit(A: TGVector4): TGVector2;

    function ToVec3(Z: Single = 0): TGVector3;
    function ToVec4(Z: Single = 0; W: Single = 0): TGVector4;

    function Cross: TGVector2; inline; // = Rotate 90
    function Dot(A: TGVector2): Single; inline;
    function SqrDot: Single; inline;
    function Length: Single; inline;
    function DistanceTo(A: TGVector2): Single; inline;
    function VectorTo(A: TGVector2): TGVector2; inline;
    function Normalize: TGVector2; inline;
    function GetAngle(A: TGVector2): Single; inline;

    function Rotate(Angel: Single): TGVector2;

    class function New(X, Y: Single): TGVector2; static;
    class function VecXY(A: TGVector3): TGVector2; static;
    class function VecYX(A: TGVector3): TGVector2; static;
    class function VecYZ(A: TGVector3): TGVector2; static;
    class function VecZY(A: TGVector3): TGVector2; static;
    class function VecZX(A: TGVector3): TGVector2; static;
    class function VecXZ(A: TGVector3): TGVector2; static;

  end;

  TGDirection = record
    T, P: Single;

    function ToPoint: TGVector; overload;
    function ToPoint(Scale: Single): TGVector; overload;
    function ToPoint(Scale: TGVector): TGVector; overload;

    function Turn(Angel: Single): TGDirection;
    function Pitch(Angel: Single): TGDirection;
    function TurnPitch(TAngel, PAngel: Single): TGDirection;

    class function New(T, P: Single): TGDirection; static;
    class function PointDir(Point: TGVector): TGDirection; static;
  end;

  TGLine = record
    SV, DV: TGVector;

    function GetPoint(Distance: Single): TGVector;

    function OrthoProj(A: TGVector): Single; overload; // Height
    function OrthoProj(A: TGVector; out S: Single): Single; overload;
    function OrthoProj(A: TGVector; out P: TGVector): Single; overload;

    function Intsec(A: TGLine): Boolean; overload;
    function Intsec(A: TGLine; out S: Single): Boolean; overload;
    function LineIntsec(A: TGLine; out P: TGVector): Boolean; overload;

    class function New(SV, DV: TGVector): TGLine; static;
  end;

  TGPlane = record
    SV, DVS, DVT: TGVector;
    function LineIntsec(A: TGLine): Boolean; overload;
    function LineIntsec(A: TGLine; out S: Single): Boolean; overload;
    function LineIntsec(A: TGLine; out S, T: Single): Boolean; overload;
    function LineIntsec(A: TGLine; out R, S, T: Single): Boolean; overload;
    function LineIntsec(A: TGLine; out P: TGVector): Boolean; overload;

    function LineInQuad(A: TGLine): Boolean; overload;
    function LineInQuad(A: TGLine; out S: Single): Boolean; overload;
    function LineInQuad(A: TGLine; out S, T: Single): Boolean; overload;
    function LineInQuad(A: TGLine; out P: TGVector): Boolean; overload;

    function LineInTri(A: TGLine): Boolean; overload;
    function LineInTri(A: TGLine; out S: Single): Boolean; overload;
    function LineInTri(A: TGLine; out S, T: Single): Boolean; overload;
    function LineInTri(A: TGLine; out P: TGVector): Boolean; overload;

    function OrthoProj(A: TGVector): Single; overload;
    function OrthoProj(A: TGVector; out S, T: Single): Single; overload;
    function OrthoProj(A: TGVector; out P: TGVector): Single; overload;

    function Normal: TGVector;

    function GetPoint(S, T: Single): TGVector;
    function GetParaPoint: TGVector;

    function GetAreaTri: Single;
    function GetAreaQuad: Single;

    class function New(SV, DVS, DVT: TGVector): TGPlane; static;
  end;

  TGEllipse = record
  private
    FDVS, FDVT: TGVector;
    procedure SetDVS(const Value: TGVector);
    procedure SetDVT(const Value: TGVector);
  public
    SV: TGVector;
    property DVS: TGVector read FDVS write SetDVS;
    property DVT: TGVector read FDVT write SetDVT;

    function GetPoint(S: Single): TGVector;

    class function NewS(SV, DVS, DVT: TGVector): TGEllipse; static;
    class function NewT(SV, DVS, DVT: TGVector): TGEllipse; static;
  end;

  TGSphere = record
    SV: TGVector;
    Scale: TGVector;

    function LineIntsec(Line: TGLine): Boolean; overload;
    function LineIntsec(Line: TGLine; out P1, P2: TGVector): Boolean; overload;

    function GetPoint(D: TGDirection): TGVector;

    class function New(SV, Scale: TGVector): TGSphere; static;
  end;

const
  Origin: TGVector4 = (X: 0; Y: 0; Z: 0; W: 1);
  UVecX: TGVector4 = (X: 1; Y: 0; Z: 0; W: 1);
  UVecY: TGVector4 = (X: 0; Y: 1; Z: 0; W: 1);
  UVecZ: TGVector4 = (X: 0; Y: 0; Z: 1; W: 1);
  UVecXY: TGVector4 = (X: 1; Y: 1; Z: 0; W: 1);
  UVecYZ: TGVector4 = (X: 0; Y: 1; Z: 1; W: 1);
  UVecXZ: TGVector4 = (X: 1; Y: 0; Z: 1; W: 1);
  UVecXYZ: TGVector4 = (X: 1; Y: 1; Z: 1; W: 1);

  VecDir: array [TGBasicDir] of TGVector = (
    (X: +1; Y:  0; Z:  0; W: 0),
    (X: -1; Y:  0; Z:  0; W: 0),
    (X:  0; Y: +1; Z:  0; W: 0),
    (X:  0; Y: -1; Z:  0; W: 0),
    (X:  0; Y:  0; Z: +1; W: 0),
    (X:  0; Y:  0; Z: -1; W: 0));

implementation

{ TGVector2 }

class operator TGVector2.Add(A, B: TGVector2): TGVector2;
begin
  Result.X := A.X + B.X;
  Result.Y := A.Y + B.Y;
end;

class operator TGVector2.Subtract(A, B: TGVector2): TGVector2;
begin
  Result.X := A.X - B.X;
  Result.Y := A.Y - B.Y;
end;

class operator TGVector2.Multiply(V: Single; A: TGVector2): TGVector2;
begin
  Result.X := V * A.X;
  Result.Y := V * A.Y;
end;

class operator TGVector2.Multiply(A: TGVector2; V: Single): TGVector2;
begin
  Result.X := V * A.X;
end;

class operator TGVector2.Multiply(A, B: TGVector): TGVector2;
begin
  Result.X := A.X * B.X;
  Result.Y := A.Y * B.Y;
end;

class operator TGVector2.Divide(V: Single; A: TGVector2): TGVector2;
begin
  Result.X := V / A.X;
  Result.Y := V / A.Y;
end;

class operator TGVector2.Divide(A: TGVector2; V: Single): TGVector2;
begin
  Result.X := A.X / V;
  Result.Y := A.Y / V;
end;

class operator TGVector2.Negative(A: TGVector2): TGVector2;
begin
  Result.X := -A.X;
  Result.Y := -A.Y;
end;

class operator TGVector2.Equal(A, B: TGVector2): Boolean;
begin
  Result := (A.X = B.X) and (A.Y = B.Y);
end;

class operator TGVector2.NotEqual(A, B: TGVector2): Boolean;
begin
  Result := (A.X <> B.X) or (A.Y <> B.Y);
end;

class operator TGVector2.LessThan(A, B: TGVector2): Boolean;
begin
  Result := (A.X < B.X) and (A.Y < B.Y);
end;

class operator TGVector2.LessThanOrEqual(A, B: TGVector2): Boolean;
begin
  Result := (A.X <= B.X) and (A.Y <= B.Y);
end;

class operator TGVector2.GreaterThan(A, B: TGVector2): Boolean;
begin
  Result := (A.X > B.X) and (A.Y > B.Y);
end;

class operator TGVector2.GreaterThanOrEqual(A, B: TGVector2): Boolean;
begin
  Result := (A.X >= B.X) and (A.Y >= B.Y);
end;

class operator TGVector2.Implicit(A: TGVector3): TGVector2;
begin
  Result.X := A.X;
  Result.Y := A.Y;
end;

class operator TGVector2.Implicit(A: TGVector4): TGVector2;
begin
  Result.X := A.X;
  Result.Y := A.Y;
end;

function TGVector2.ToVec3(Z: Single): TGVector3;
begin
  Result.X := X;
  Result.Y := Y;
  Result.Z := Z;
end;

function TGVector2.ToVec4(Z: Single; W: Single): TGVector4;
begin
  Result.X := X;
  Result.Y := Y;
  Result.Z := Z;
  Result.W := W;
end;

function TGVector2.Cross: TGVector2;
begin
  Result.X := -Y;
  Result.Y := X;
end;

function TGVector2.Dot(A: TGVector2): Single;
begin
  Result := X * A.X + Y * A.Y;
end;

function TGVector2.SqrDot: Single;
begin
  Result := Sqr(X) + Sqr(Y);
end;

function TGVector2.Length: Single;
begin
  Result := Sqrt(SqrDot);
end;

function TGVector2.DistanceTo(A: TGVector2): Single;
begin
  Result := VectorTo(A).Length;
end;

function TGVector2.VectorTo(A: TGVector2): TGVector2;
begin
  Result := A - Self;
end;

function TGVector2.Normalize: TGVector2;
begin
  Result := Self / Length;
end;

function TGVector2.GetAngle(A: TGVector2): Single;
begin
  Result := ArcCos(Dot(A) / (Length * A.Length)) * 180 / Pi;
end;

function TGVector2.Rotate(Angel: Single): TGVector2;
begin
  Angel := Angel * Pi / 180;
  Result := Sin(Angel) * Cross + Cos(Angel) * Self;
end;

class function TGVector2.New(X, Y: Single): TGVector2;
begin
  Result.X := X;
  Result.Y := Y;
end;

class function TGVector2.VecXY(A: TGVector3): TGVector2;
begin
  Result.X := A.X;
  Result.Y := A.Y;
end;

class function TGVector2.VecYX(A: TGVector3): TGVector2;
begin
  Result.X := A.Y;
  Result.Y := A.X;
end;

class function TGVector2.VecYZ(A: TGVector3): TGVector2;
begin
  Result.X := A.Y;
  Result.Y := A.Z;
end;

class function TGVector2.VecZY(A: TGVector3): TGVector2;
begin
  Result.X := A.Z;
  Result.Y := A.Y;
end;

class function TGVector2.VecZX(A: TGVector3): TGVector2;
begin
  Result.X := A.Z;
  Result.Y := A.X;
end;

class function TGVector2.VecXZ(A: TGVector3): TGVector2;
begin
  Result.X := A.X;
  Result.Y := A.Z;
end;

{ TGVector3 }

class operator TGVector3.Add(A, B: TGVector3): TGVector3;
begin
  Result.X := A.X + B.X;
  Result.Y := A.Y + B.Y;
  Result.Z := A.Z + B.Z;
end;

class operator TGVector3.Subtract(A, B: TGVector3): TGVector3;
begin
  Result.X := A.X - B.X;
  Result.Y := A.Y - B.Y;
  Result.Z := A.Z - B.Z;
end;

class operator TGVector3.Multiply(V: Single; A: TGVector3): TGVector3;
begin
  Result.X := V * A.X;
  Result.Y := V * A.Y;
  Result.Z := V * A.Z;
end;

class operator TGVector3.Multiply(A: TGVector3; V: Single): TGVector3;
begin
  Result.X := A.X * V;
  Result.Y := A.Y * V;
  Result.Z := A.Z * V;
end;

class operator TGVector3.Multiply(A, B: TGVector): TGVector3;
begin
  Result.X := A.X * B.X;
  Result.Y := A.Y * B.Y;
  Result.Z := A.Z * B.Z;
end;

class operator TGVector3.Divide(V: Single; A: TGVector3): TGVector3;
begin
  Result.X := V / A.X;
  Result.Y := V / A.Y;
  Result.Z := V / A.Z;
end;

class operator TGVector3.Divide(A: TGVector3; V: Single): TGVector3;
begin
  Result.X := A.X / V;
  Result.Y := A.Y / V;
  Result.Z := A.Z / V;
end;

class operator TGVector3.Negative(A: TGVector3): TGVector3;
begin
  Result.X := -A.X;
  Result.Y := -A.Y;
  Result.Z := -A.Z;
end;

class operator TGVector3.Equal(A, B: TGVector3): Boolean;
begin
  Result := (A.X = B.X) and (A.Y = B.Y) and (A.Z = B.Z);
end;

class operator TGVector3.NotEqual(A, B: TGVector3): Boolean;
begin
  Result := (A.X <> B.X) or (A.Y <> B.Y) or (A.Z <> B.Z);
end;

class operator TGVector3.LessThan(A, B: TGVector3): Boolean;
begin
  Result := (A.X < B.X) and (A.Y < B.Y) and (A.Z < B.Z);
end;

class operator TGVector3.LessThanOrEqual(A, B: TGVector3): Boolean;
begin
  Result := (A.X <= B.X) and (A.Y <= B.Y) and (A.Z <= B.Z);
end;

class operator TGVector3.GreaterThan(A, B: TGVector3): Boolean;
begin
  Result := (A.X > B.X) and (A.Y > B.Y) and (A.Z > B.Z);
end;

class operator TGVector3.GreaterThanOrEqual(A, B: TGVector3): Boolean;
begin
  Result := (A.X >= B.X) and (A.Y >= B.Y) and (A.Z >= B.Z);
end;

class operator TGVector3.Implicit(A: TGVector): TGVector3;
begin
  Result.X := A.X;
  Result.Y := A.Y;
  Result.Z := A.Z;
end;

function TGVector3.ToVec4(W: Single): TGVector4;
begin
  Result.X := X;
  Result.Y := Y;
  Result.Z := Z;
  Result.W := W;
end;

function TGVector3.Cross(A: TGVector3): TGVector3;
begin
  if (Self = Origin) or (A = Origin) then
    Result := Origin
  else
  begin
    Result.X := Y * A.Z - Z * A.Y;
    Result.Y := Z * A.X - X * A.Z;
    Result.Z := X * A.Y - Y * A.X;
  end;
end;

function TGVector3.Dot(A: TGVector3): Single;
begin
  Result := X * A.X + Y * A.Y + Z * A.Z;
end;

function TGVector3.SqrDot: Single;
begin
  Result := Sqr(X) + Sqr(Y) + Sqr(Z);
end;

function TGVector3.Length: Single;
begin
  Result := Sqrt(SqrDot);
end;

function TGVector3.DistanceTo(A: TGVector3): Single;
begin
  Result := (A - Self).Length;
end;

function TGVector3.VectorTo(A: TGVector3): TGVector3;
begin
  Result := A - Self;
end;

function TGVector3.Normalize: TGVector3;
begin
  Result := Self / Length;
end;

function TGVector3.GetAngel(A: TGVector3): Single;
begin
  Result := ArcCos(Dot(A) / (Length * A.Length)) * 180 / Pi;
end;

function TGVector3.Rotate(A: TGVector3; Angel: Single): TGVector3;
var
  UX, UZ: TGVector3;
  VX, VY: Single;
begin
  Angel := Angel * Pi / 180;

  A := A.Normalize;

  UZ := Self.Cross(A);
  UX := A.Cross(UZ);

  VX := UX.Dot(Self) / UX.Dot(UX);
  VY := A.Dot(Self) / A.Dot(A);

  Result := Cos(Angel) * VX * UX + VY * A + Sin(Angel) * VX * UZ;
end;

class function TGVector3.New(X, Y, Z: Single): TGVector3;
begin
  Result.X := X;
  Result.Y := Y;
  Result.Z := Z;
end;

{ TGLine }

function TGLine.GetPoint(Distance: Single): TGVector;
begin
  Result := Self.SV + Self.DV * Distance;
end;

function TGLine.LineIntsec(A: TGLine; out P: TGVector): Boolean;
var
  S: Single;
begin
  if Intsec(A, S) then
  begin
    Result := True;
    P := GetPoint(S);
  end
  else
    Result := False;
end;

class function TGLine.New(SV, DV: TGVector): TGLine;
begin
  Result.SV := SV;
  Result.DV := DV;
end;

function TGLine.OrthoProj(A: TGVector): Single;
begin
  Result := (GetPoint(DV.Dot(A - SV) / DV.Dot(DV)) - A).Length;
end;

function TGLine.OrthoProj(A: TGVector; out S: Single): Single;
begin
  S := DV.Dot(A - SV) / DV.Dot(DV);
  Result := (GetPoint(S) - A).Length;
end;

function TGLine.OrthoProj(A: TGVector; out P: TGVector): Single;
var
  S: Single;
begin
  Result := OrthoProj(A, S);
  P := GetPoint(S);
end;

function TGLine.Intsec(A: TGLine): Boolean;
var
  P: array [0 .. 1] of Single;
begin
  // Theorie: Self.SV + S * Self.DV = A.SV + T * A.DV
  // >  S * Self.DV + T * A.DV = A.SV - Self.SV
  M3x2[0, 0] := Self.DV.X;
  M3x2[1, 0] := A.DV.X;
  M3x2[2, 0] := A.SV.X - Self.SV.X;
  M3x2[0, 1] := Self.DV.Y;
  M3x2[1, 1] := A.DV.Y;
  M3x2[2, 1] := A.SV.Y - Self.SV.Y;
  if M3x2.Solve(P) then
    Result := (P[0] * Self.DV.Z + P[1] * A.DV.Z) = (A.SV.Z - Self.SV.Z)
  else
    Result := False;
end;

function TGLine.Intsec(A: TGLine; out S: Single): Boolean;
var
  P: array [0 .. 1] of Single;
begin
  M3x2[0, 0] := Self.DV.X;
  M3x2[1, 0] := A.DV.X;
  M3x2[2, 0] := A.SV.X - Self.SV.X;
  M3x2[0, 1] := Self.DV.Y;
  M3x2[1, 1] := A.DV.Y;
  M3x2[2, 1] := A.SV.Y - Self.SV.Y;
  if M3x2.Solve(P) then
  begin
    Result := (P[0] * Self.DV.Z + P[1] * A.DV.Z) <> (A.SV.Z - Self.SV.Z);
    if Result then
       S := P[0];
  end
  else
    Result := False;
end;

{ TGPlane }

function TGPlane.LineIntsec(A: TGLine): Boolean;
var
  P: array [0 .. 2] of Single;
begin
  // Theorie: Self.SV + S * Self.DVS + T * Self.DVT = A.SV + U * A.DV
  // > S * Self.DVS + T * Self.DVT - U * A.DV = A.SV - Self.SV
  M4x3[0, 0] := Self.DVS.X;
  M4x3[1, 0] := Self.DVT.X;
  M4x3[2, 0] := -A.DV.X;
  M4x3[3, 0] := A.SV.X - Self.SV.X;
  M4x3[0, 1] := Self.DVS.Y;
  M4x3[1, 1] := Self.DVT.Y;
  M4x3[2, 1] := -A.DV.Y;
  M4x3[3, 1] := A.SV.Y - Self.SV.Y;
  M4x3[0, 2] := Self.DVS.Z;
  M4x3[1, 2] := Self.DVT.Z;
  M4x3[2, 2] := -A.DV.Z;
  M4x3[3, 2] := A.SV.Z - Self.SV.Z;

  Result := M4x3.Solve(P);
end;

function TGPlane.LineIntsec(A: TGLine; out S: Single): Boolean;
var
  P: array [0 .. 2] of Single;
begin
  M4x3[0, 0] := Self.DVS.X;
  M4x3[1, 0] := Self.DVT.X;
  M4x3[2, 0] := -A.DV.X;
  M4x3[3, 0] := A.SV.X - Self.SV.X;
  M4x3[0, 1] := Self.DVS.Y;
  M4x3[1, 1] := Self.DVT.Y;
  M4x3[2, 1] := -A.DV.Y;
  M4x3[3, 1] := A.SV.Y - Self.SV.Y;
  M4x3[0, 2] := Self.DVS.Z;
  M4x3[1, 2] := Self.DVT.Z;
  M4x3[2, 2] := -A.DV.Z;
  M4x3[3, 2] := A.SV.Z - Self.SV.Z;

  Result := M4x3.Solve(P);
  S := P[2];
end;

function TGPlane.LineIntsec(A: TGLine; out S, T: Single): Boolean;
var
  P: array [0 .. 2] of Single;
begin
  M4x3[0, 0] := Self.DVS.X;
  M4x3[1, 0] := Self.DVT.X;
  M4x3[2, 0] := -A.DV.X;
  M4x3[3, 0] := A.SV.X - Self.SV.X;
  M4x3[0, 1] := Self.DVS.Y;
  M4x3[1, 1] := Self.DVT.Y;
  M4x3[2, 1] := -A.DV.Y;
  M4x3[3, 1] := A.SV.Y - Self.SV.Y;
  M4x3[0, 2] := Self.DVS.Z;
  M4x3[1, 2] := Self.DVT.Z;
  M4x3[2, 2] := -A.DV.Z;
  M4x3[3, 2] := A.SV.Z - Self.SV.Z;

  Result := M4x3.Solve(P);
  S := P[0];
  T := P[1];
end;

function TGPlane.GetAreaQuad: Single;
begin
  Result := DVS.Cross(DVT).Length;
end;

function TGPlane.GetAreaTri: Single;
begin
  Result := DVS.Cross(DVT).Length / 2;
end;

function TGPlane.OrthoProj(A: TGVector): Single;
var
  S, T: Single;
begin
  S := (DVT.Dot(DVT) * DVS.Dot(A - SV) - DVT.Dot(DVS) * DVT.Dot(A - SV)) /
    (DVS.Dot(DVS) * DVT.Dot(DVT) - DVS.Dot(DVT) * DVS.Dot(DVT));
  T := (DVS.Dot(DVS) * DVT.Dot(A - SV) - DVS.Dot(DVT) * DVS.Dot(A - SV)) /
    (DVT.Dot(DVT) * DVS.Dot(DVS) - DVT.Dot(DVS) * DVT.Dot(DVS));
  Result := (GetPoint(S, T) - A).Length;
end;

function TGPlane.OrthoProj(A: TGVector; out S, T: Single): Single;
begin
  S := (DVT.SqrDot * DVS.Dot(A - SV) - DVT.Dot(DVS) * DVT.Dot(A - SV)) /
    (DVS.SqrDot * DVT.SqrDot - DVS.Dot(DVT) * DVS.Dot(DVT));
  T := (DVS.SqrDot * DVT.Dot(A - SV) - DVS.Dot(DVT) * DVS.Dot(A - SV)) /
    (DVT.SqrDot * DVS.SqrDot - DVT.Dot(DVS) * DVT.Dot(DVS));
  Result := (GetPoint(S, T) - A).Length;
end;

function TGPlane.OrthoProj(A: TGVector; out P: TGVector): Single;
var
  S, T: Single;
begin
  Result := OrthoProj(A, S, T);
  P := GetPoint(S, T);
end;

function TGPlane.GetParaPoint: TGVector;
begin
  Result := GetPoint(1, 1);
end;

function TGPlane.GetPoint(S, T: Single): TGVector;
begin
  Result := SV + S * DVS + T * DVT;
end;

function TGPlane.LineInQuad(A: TGLine): Boolean;
var
  S, T: Single;
begin
  Result := LineIntsec(A, S, T) and (S >= 0) and (S <= 1) and (T >= 0)
    and (T <= 1);
end;

function TGPlane.LineInTri(A: TGLine): Boolean;
var
  S, T: Single;
begin
  Result := LineIntsec(A, S, T) and (S >= 0) and (T >= 0) and (S + T <= 1);
end;

function TGPlane.LineIntsec(A: TGLine; out P: TGVector): Boolean;
var
  S: Single;
begin
  Result := LineIntsec(A, S);
  P := A.GetPoint(S);
end;

class function TGPlane.New(SV, DVS, DVT: TGVector): TGPlane;
begin
  Result.SV := SV;
  Result.DVS := DVS;
  Result.DVT := DVT;
end;

function TGPlane.Normal: TGVector;
begin
  Result := DVS.Cross(DVT).Normalize;
end;

function TGPlane.LineInQuad(A: TGLine; out S, T: Single): Boolean;
begin
  Result := LineIntsec(A, S, T) and (S >= 0) and (S <= 1) and (T >= 0) and (T <= 1);
end;

function TGPlane.LineInQuad(A: TGLine; out P: TGVector): Boolean;
var
  S, T: Single;
begin
  Result := LineIntsec(A, S, T) and (S >= 0) and (S <= 1) and (T >= 0) and (T <= 1);
  P := GetPoint(S, T);
end;

function TGPlane.LineInQuad(A: TGLine; out S: Single): Boolean;
var
  X, Y: Single;
begin
  Result := LineIntsec(A, S, X, Y) and (X >= 0) and (X <= 1) and (Y >= 0) and (Y <= 1);
end;

function TGPlane.LineInTri(A: TGLine; out S: Single): Boolean;
var
  X, Y: Single;
begin
  Result := LineIntsec(A, X, Y) and (X >= 0) and (Y >= 0) and (X + Y <= 1);
  S := GetPoint(X, Y).DistanceTo(A.SV);
end;

function TGPlane.LineInTri(A: TGLine; out S, T: Single): Boolean;
begin
  Result := LineIntsec(A, S, T) and (S >= 0) and (T >= 0) and (S + T <= 1);
end;

function TGPlane.LineInTri(A: TGLine; out P: TGVector): Boolean;
var
  S, T: Single;
begin
  Result := LineIntsec(A, S, T) and (S >= 0) and (T >= 0) and (S + T <= 1);
  P := GetPoint(S, T);
end;

function TGPlane.LineIntsec(A: TGLine; out R, S, T: Single): Boolean;
var
  P: array [0 .. 2] of Single;
begin
  M4x3[0, 0] := Self.DVS.X;
  M4x3[1, 0] := Self.DVT.X;
  M4x3[2, 0] := -A.DV.X;
  M4x3[3, 0] := A.SV.X - Self.SV.X;
  M4x3[0, 1] := Self.DVS.Y;
  M4x3[1, 1] := Self.DVT.Y;
  M4x3[2, 1] := -A.DV.Y;
  M4x3[3, 1] := A.SV.Y - Self.SV.Y;
  M4x3[0, 2] := Self.DVS.Z;
  M4x3[1, 2] := Self.DVT.Z;
  M4x3[2, 2] := -A.DV.Z;
  M4x3[3, 2] := A.SV.Z - Self.SV.Z;

  Result := M4x3.Solve(P);
  S := P[0];
  T := P[1];
  R := P[2];
end;

{ TGSphere }

function TGSphere.GetPoint(D: TGDirection): TGVector;
begin
  Result := SV + D.ToPoint(Scale);
end;

function TGSphere.LineIntsec(Line: TGLine): Boolean;
begin
  Line.SV := Line.SV / Scale;
  Line.DV := Line.DV * Scale;
  Result := Line.OrthoProj(SV / Scale) <= 1;
end;

function TGSphere.LineIntsec(Line: TGLine; out P1, P2: TGVector): Boolean;
var
  Dis: Single;
begin
  Line.SV := Line.SV / Scale;
  Line.DV := Line.DV / Scale;
  Dis := Line.OrthoProj(SV / Scale, P1);
  if Dis > 1 then
    Result := False
  else
  begin
    P2 := (P1 - Line.DV.Normalize * sqrt(1 - Dis * Dis)) * Scale;
    P1 := (P1 + Line.DV.Normalize * sqrt(1 - Dis * Dis)) * Scale;
    Result := True;
  end;
end;

class function TGSphere.New(SV, Scale: TGVector): TGSphere;
begin
  Result.SV := SV;
  Result.Scale := Scale;
end;

{ TGEllipse }

function TGEllipse.GetPoint(S: Single): TGVector;
begin
  Result := SV + Sin(S) * DVS + Cos(S) * DVT;
end;

class function TGEllipse.NewS(SV, DVS, DVT: TGVector): TGEllipse;
begin
  Result.SV := SV;
  Result.FDVT := DVT;
  Result.DVS := DVS;
end;

class function TGEllipse.NewT(SV, DVS, DVT: TGVector): TGEllipse;
begin
  Result.SV := SV;
  Result.FDVS := DVS;
  Result.DVT := DVT;
end;

procedure TGEllipse.SetDVS(const Value: TGVector);
var
  N: TGVector;
begin
  FDVS := Value;
  N := DVS.Cross(DVT);
  FDVT := N.Cross(DVS) / DVS.Dot(DVS);
end;

procedure TGEllipse.SetDVT(const Value: TGVector);
var
  N: TGVector;
begin
  FDVT := Value;
  N := DVT.Cross(DVS);
  FDVS := N.Cross(DVT) / DVT.Dot(DVT);
end;

{ TGDirection }

function TGDirection.ToPoint: TGVector;
begin
  Result := TGVector.New(Sin(T) * Cos(P / 2), Sin(P / 2), Cos(T) * Cos(P / 2), 0);
end;

class function TGDirection.New(T, P: Single): TGDirection;
begin
  Result.T := T;
  Result.P := P;
end;

function TGDirection.Pitch(Angel: Single): TGDirection;
begin
  Result.T := T;
  Result.P := P + Angel / 180 * Pi;
end;

class function TGDirection.PointDir(Point: TGVector): TGDirection;
var
  T: Single;
begin
  Point := Point.Normalize;
  Result.P := ArcSin(Point.Y);
  T := Point.X / Sqrt(1 - sqr(Point.Y));
  Result.T := ArcSin(T);
  if Point.Z > 0 then
    Result.T := Pi - Result.T;
end;

function TGDirection.ToPoint(Scale: Single): TGVector;
begin
  Result := TGVector.New(Sin(T) * Cos(P / 2), Sin(P / 2), Cos(T) * Cos(P / 2), 0) * Scale;
end;

function TGDirection.ToPoint(Scale: TGVector): TGVector;
begin
  Result := TGVector.New(Sin(T) * Cos(P / 2), Sin(P / 2), Cos(T) * Cos(P / 2), 0) * Scale;
end;

function TGDirection.Turn(Angel: Single): TGDirection;
begin
  Result.T := T + Angel / 180 * Pi;
  Result.P := P;
end;

function TGDirection.TurnPitch(TAngel, PAngel: Single): TGDirection;
begin
  Result.T := T + TAngel / 180 * Pi;
  Result.P := P + PAngel / 180 * Pi;
end;

{ TGVector }

class operator TGVector.Add(A, B: TGVector): TGVector;
begin
  Result.X := A.X + B.X;
  Result.Y := A.Y + B.Y;
  Result.Z := A.Z + B.Z;
  Result.W := A.W;
end;

function TGVector.Cross(A: TGVector): TGVector;
begin
  if (Self = Origin) or (A = Origin) then
    Result := Origin
  else
  begin
    Result.X := Y * A.Z - Z * A.Y;
    Result.Y := Z * A.X - X * A.Z;
    Result.Z := X * A.Y - Y * A.X;
    Result.W := Self.W;
  end;
end;

function TGVector.DistanceTo(A: TGVector): Single;
begin
  Result := VectorTo(A).Length;
end;

class operator TGVector.Divide(A: TGVector; V: Single): TGVector;
begin
  Result.X := A.X / V;
  Result.Y := A.Y / V;
  Result.Z := A.Z / V;
  Result.W := A.W;
end;

class operator TGVector.Divide(V: Single; A: TGVector): TGVector;
begin
  Result.X := V / A.X;
  Result.Y := V / A.Y;
  Result.Z := V / A.Z;
  Result.W := A.W;
end;

class operator TGVector.Divide(A, B: TGVector): TGVector;
begin
  Result.X := A.X / B.X;
  Result.Y := A.Y / B.Y;
  Result.Z := A.Z / B.Z;
  Result.W := A.W;
end;

function TGVector.Dot(A: TGVector): Single;
begin
  Result := X * A.X + Y * A.Y + Z * A.Z;
end;

class operator TGVector.Equal(A, B: TGVector): Boolean;
begin
  Result := (A.X = B.X) and (A.Y = B.Y) and (A.Z = B.Z);
end;

function TGVector.VectorTo(A: TGVector): TGVector;
begin
  Result := A - Self;
end;

function TGVector.Length: Single;
begin
  Result := Sqrt(SqrDot);
end;

class operator TGVector.Multiply(A, B: TGVector): TGVector;
begin
  Result.X := A.X * B.X;
  Result.Y := A.Y * B.Y;
  Result.Z := A.Z * B.Z;
  Result.W := A.W;
end;

class operator TGVector.Multiply(A: TGVector; V: Single): TGVector;
begin
  Result.X := A.X * V;
  Result.Y := A.Y * V;
  Result.Z := A.Z * V;
  Result.W := A.W;
end;

class operator TGVector.Multiply(V: Single; A: TGVector): TGVector;
begin
  Result := A * V;
end;

class operator TGVector.Negative(A: TGVector): TGVector;
begin
  Result.X := -A.X;
  Result.Y := -A.Y;
  Result.Z := -A.Z;
  Result.W := A.W;
end;

class function TGVector.New(X, Y, Z : Single; W : Single) : TGVector;
begin
  Result.X := X;
  Result.Y := Y;
  Result.Z := Z;
  Result.W := W;
end;

function TGVector.Normalize: TGVector;
begin
  Result := Self / Self.Length;
end;

function TGVector.GetAngel(A: TGVector): Single;
begin
  Result := ArcCos(Dot(A) / (Length * A.Length)) * 180 / Pi;
end;

class operator TGVector.NotEqual(A, B: TGVector): Boolean;
begin
  Result := (A.X <> B.X) or (A.Y <> B.Y) or (A.Z <> B.Z);
end;

class operator TGVector.LessThan(A, B : TGVector) : Boolean;
begin
  Result := (A.X < B.X) and (A.Y < B.Y) and (A.Z < B.Z);
end;

class operator TGVector.LessThanOrEqual(A, B : TGVector) : Boolean;
begin
  Result := (A.X <= B.X) and (A.Y <= B.Y) and (A.Z <= B.Z);
end;

class operator TGVector.GreaterThan(A, B: TGVector): Boolean;
begin
  Result := (A.X > B.X) and (A.Y > B.Y) and (A.Z > B.Z);
end;

class operator TGVector.GreaterThanOrEqual(A, B: TGVector): Boolean;
begin
  Result := (A.X >= B.X) and (A.Y >= B.Y) and (A.Z >= B.Z);
end;

function TGVector.Rotate(A: TGVector; Angel: Single): TGVector;
var
  UX, UZ: TGVector;
  VX, VY: Single;
begin
  Angel := Angel * Pi / 180;

  A := A.Normalize;

  UZ := Self.Cross(A);
  UX := A.Cross(UZ);

  VX := UX.Dot(Self) / UX.Dot(UX);
  VY := A.Dot(Self) / A.Dot(A);

  Result := Cos(Angel) * VX * UX + VY * A + Sin(Angel) * VX * UZ;
end;

class operator TGVector.Subtract(A, B: TGVector): TGVector;
begin
  Result.X := A.X - B.X;
  Result.Y := A.Y - B.Y;
  Result.Z := A.Z - B.Z;
  Result.W := A.W;
end;

function TGVector.SqrDot: Single;
begin
  Result := sqr(X) + sqr(Y) + sqr(Z);
end;

end.
