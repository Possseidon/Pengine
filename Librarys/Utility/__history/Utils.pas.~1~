unit Utils;

{$mode Delphi}

interface

uses
  Windows, Math, Graphics;

function GetDistance(X1, Y1, X2, Y2: Real): Real;
function GetAngle(X1, Y1, X2, Y2: Real): Real;
procedure RotateBmp(CX, CY, R: Real; var Bitmap: TBitmap);

function PointInRect(X1, Y1, X2, Y2, Width, Height: Integer): Boolean;

function HSVtoRGB(H: Integer; S, V: Byte): TColor;
procedure RGBtoHSV(Red, Green, Blue: Byte; var Hue: Integer;
  var Saturation, Value: Byte);

procedure MirrorH(var Bitmap: TBitmap);
procedure MirrorV(var Bitmap: TBitmap);

procedure SleepEx(Ticks: Cardinal);

function RoundNearest(X: Real): Integer;

function RealMod(X, Min, Max: Real): Real;

implementation

uses
  SysUtils;

procedure RGBtoHSV(Red, Green, Blue: Byte; var Hue: Integer;
  var Saturation, Value: Byte);
var
  Maximum, Minimum: Byte;
  Rc, Gc, Bc: Single;
  H: Single;
begin
  Maximum := Max(Red, Max(Green, Blue));
  Minimum := Min(Red, Min(Green, Blue));
  Value := Maximum;
  if Maximum <> 0 then
    Saturation := MulDiv(Maximum - Minimum, 255, Maximum)
  else
    Saturation := 0;
  if Saturation = 0 then
    Hue := 0 // arbitrary value
  else
  begin
    Assert(Maximum <> Minimum);
    Rc := (Maximum - Red) / (Maximum - Minimum);
    Gc := (Maximum - Green) / (Maximum - Minimum);
    Bc := (Maximum - Blue) / (Maximum - Minimum);
    if Red = Maximum then
      H := Bc - Gc
    else if Green = Maximum then
      H := 2 + Rc - Bc
    else
    begin
      Assert(Blue = Maximum);
      H := 4 + Gc - Rc;
    end;
    H := H * 60;
    if H < 0 then
      H := H + 360;
    Hue := Round(H);
  end;
end;

function HSVtoRGB(H: Integer; S, V: Byte): TColor;
var
  ht, d, t1, t2, t3: Integer;
  R, G, B: Word;
begin
  if S = 0 then
  begin
    R := V;
    G := V;
    B := V;
  end
  else
  begin
    ht := H * 6;
    d := ht mod 360;

    t1 := Round(V * (255 - S) / 255);
    t2 := Round(V * (255 - S * d / 360) / 255);
    t3 := Round(V * (255 - S * (360 - d) / 360) / 255);

    case ht div 360 of
      0:
        begin
          R := V;
          G := t3;
          B := t1;
        end;
      1:
        begin
          R := t2;
          G := V;
          B := t1;
        end;
      2:
        begin
          R := t1;
          G := V;
          B := t3;
        end;
      3:
        begin
          R := t1;
          G := t2;
          B := V;
        end;
      4:
        begin
          R := t3;
          G := t1;
          B := V;
        end;
    else
      begin
        R := V;
        G := t1;
        B := t2;
      end;
    end;
  end;

  Result := RGB(R, G, B);
end;

function PointInRect(X1, Y1, X2, Y2, Width, Height: Integer): Boolean;
begin
  if (X1 >= X2) and (Y1 >= Y2) and (X1 < X2 + Width) and (Y1 < Y2 + Height) then
    Result := True
  else
    Result := False;
end;

procedure MirrorH(var Bitmap: TBitmap);
var
  Hlp: TBitmap;
  X, Y: Integer;
begin
  Hlp := TBitmap.Create;
  Hlp.Assign(Bitmap);

  for X := 0 to Hlp.Width do
    for Y := 0 to Hlp.Height do
      Hlp.Canvas.Pixels[X - 1, Y] := Bitmap.Canvas.Pixels[Hlp.Width - X, Y];

  Bitmap.Assign(Hlp);
  Hlp.Free;
end;

procedure MirrorV(var Bitmap: TBitmap);
var
  Hlp: TBitmap;
  X, Y: Integer;
begin
  Hlp := TBitmap.Create;
  Hlp.Assign(Bitmap);

  for X := 0 to Hlp.Width do
    for Y := 0 to Hlp.Height do
      Hlp.Canvas.Pixels[X - 1, Y] := Bitmap.Canvas.Pixels[X, Hlp.Height - Y];

  Bitmap.Assign(Hlp);

  Hlp.Free;
end;

function GetDistance(X1, Y1, X2, Y2: Real): Real;
begin
  Result := sqrt(Power(X2 - X1, 2) + Power(Y2 - Y1, 2));
end;

function GetAngle(X1, Y1, X2, Y2: Real): Real;
var
  DX, DY: Extended;
begin
  DX := X2 - X1;
  DY := Y2 - Y1;

  try
    if DY <> 0 then
      Result := ArcCos(-DY / GetDistance(X1, Y1, X2, Y2))
    else
      Result := ArcCos(0);
    if DX < 0 then
      Result := 2 * Pi - Result;
  except
    Result := 0;
  end;
end;

procedure RotateBmp(CX, CY, R: Real; var Bitmap: TBitmap);
var
  X, Y, NX, NY: Integer;
  Angle, Distance: Double;
  TmpBmp: TBitmap;
begin
  if Round(R + 360) mod 360 <> 0 then
  begin
    TmpBmp := TBitmap.Create;
    TmpBmp.Width := Bitmap.Width;
    TmpBmp.Height := Bitmap.Height;

    for Y := 0 to Pred(Bitmap.Height) do
      for X := 0 to Pred(Bitmap.Width) do
      begin
        Distance := GetDistance(CX, CY, X, Y);
        Angle := Pi - GetAngle(CX, CY, X, Y);
        NX := Round(CX + sin(Angle + (R * Pi / 180)) * Distance);
        NY := Round(CY + cos(Angle + (R * Pi / 180)) * Distance);
        if (NX >= 0) and (NX < Bitmap.Width) and (NY >= 0) and
          (NY < Bitmap.Height) then
          TmpBmp.Canvas.Pixels[X, Y] := Bitmap.Canvas.Pixels[NX, NY];
      end;

    Bitmap.Assign(TmpBmp);

    TmpBmp.Free;
  end;
end;

procedure SleepEx(Ticks: Cardinal); assembler;
asm
@loop:  DEC Ticks;
  JNZ @loop;
end;

function RoundNearest(X: Real): Integer;
begin
  Result := Floor(X + 0.5);
end;

function RealMod(X, Min, Max: Real): Real;
var
  Range: Real;
begin
  Range := Max - Min;
  Result := X - Floor((X - Min) / Range) * Range;
end;

end.
