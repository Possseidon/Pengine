unit ObjectList;

{$IFDEF FPC}
{$mode Delphi}
{$ENDIF}

interface

uses
  Classes, SysUtils, Sorting;

type

  TWithEachProcedureBasic = procedure (AElement: TObject) of object;

  TWithEachProcedure = class abstract
    procedure WithEach(AElement: TObject); virtual; abstract;
  end;

  TFindFunction = class abstract
    function Find(AElement: TObject): Boolean; virtual; abstract;
  end;

  TCompareFunction = class abstract
    function Compare(AElement1, AElement2: TObject): Boolean; virtual; abstract;
  end;

  TIterateDirection = (idAscending, idDescending);

  { TObjectList }

  TObjectList = class
  strict private
    type
      TItem = class
        Data: TObject;
        Next, Prev: TItem;
      end;

  strict private
    FFirst: TItem;
    FLast: TItem;
    FCount: Integer;

    FReferenceList: Boolean;

    function Find(AElement: TObject): TItem;
    procedure Del(AItem: TItem); overload;
    function GetItem(I: Integer): TObject;
  public
    type
      TIterator = class
      private
        FPos: TItem;
        FDirection: TIterateDirection;
      public
        constructor Create(AList: TObjectList; AIterateDirection: TIterateDirection = idAscending);
        destructor Destroy; override;

        function Iterating: Boolean;
        function Current: TObject;
        procedure Next;
        procedure Stop;
      end;
  public
    constructor Create(AReferenceList: Boolean = False);
    destructor Destroy; override;

    procedure Add(AElement: TObject);
    procedure Del(AElement: TObject); overload;

    procedure WithEach(AFunc: TWithEachProcedure; AFreeFunction: Boolean = True); overload;
    procedure WithEach(AFunc: TWithEachProcedureBasic); overload;
    function FindFirst(AFunc: TFindFunction; AFreeFunction: Boolean = True): TObject;
    function FindLast(AFunc: TFindFunction; AFreeFunction: Boolean = True): TObject;
    function FindAll(AFunc: TFindFunction; AFreeFunction: Boolean = True): TObjectList;

    procedure Sort(AFunc: TCompareFunction);

    property Count: Integer read FCount;

    function Iterate(AIteratorDirection: TIterateDirection = idAscending): TIterator;

    property Item[I: Integer]: TObject read GetItem; default;
  end;

  { TObjectArray }

  TObjectArray = class
  private
    FItems: array of TObject;

    function GetItem(I: Integer): TObject;

  public
    property Item[I: Integer]: TObject read GetItem; default;
  end;

implementation

{ TObjectArray }

function TObjectArray.GetItem(I: Integer): TObject;
begin

end;

{ TObjectList.TIterator }

constructor TObjectList.TIterator.Create(AList: TObjectList; AIterateDirection: TIterateDirection);
begin
  FDirection := AIterateDirection;
  case FDirection of
    idAscending:
      FPos := AList.FFirst;
    idDescending:
      FPos := AList.FLast;
  end;
end;

destructor TObjectList.TIterator.Destroy;
begin
  inherited Destroy;
end;

function TObjectList.TIterator.Iterating: Boolean;
begin
  Result := FPos <> nil;
  if not Result then
    Free;
end;

function TObjectList.TIterator.Current: TObject;
begin
  if FPos <> nil then
    Result := FPos.Data
  else
    Result := nil;
end;

procedure TObjectList.TIterator.Next;
begin
  if FPos <> nil then
    case FDirection of
      idAscending:
        FPos := FPos.Next;
      idDescending:
        FPos := FPos.Prev;
    end;
end;

procedure TObjectList.TIterator.Stop;
begin
  FPos := nil;
end;

{ TObjectList }

function TObjectList.Find(AElement: TObject): TItem;
var
  I: TItem;
begin
  I := FFirst;
  while (I <> nil) and (Pointer(I.Data) <> Pointer(AElement)) do
    I := I.Next;
  if I = nil then
    raise Exception.Create('TODO! Could not find Element in List');
  Result := I;
end;

procedure TObjectList.Del(AItem: TItem);
begin
  with AItem do
  begin
    if Prev = nil then
      FFirst := Next
    else
      Prev.Next := Next;
    if Next = nil then
      FLast := Prev
    else
      Next.Prev := Prev;

    if not FReferenceList then
      Data.Free;
    Free;
  end;
  FCount := FCount - 1;
end;

function TObjectList.GetItem(I: Integer): TObject;
var
  FPos: TItem;
begin
  if (I >= Count) or (I < 0) then
    raise Exception.Create('Item out of bounds'); // TODO: ObjectList Get Item Exception
  FPos := FFirst;
  while I > 0 do
  begin
    FPos := FPos.Next;
    Dec(I);
  end;
  Result := FPos.Data;
end;

constructor TObjectList.Create(AReferenceList: Boolean);
begin
  FReferenceList := AReferenceList;
end;

destructor TObjectList.Destroy;
begin
  while FCount > 0 do
    Del(FLast);
  inherited Destroy;
end;

procedure TObjectList.Add(AElement: TObject);
begin
   if FLast = nil then
  begin
    FFirst := TItem.Create;
    FLast := FFirst;
    FFirst.Data := AElement;
  end
  else
  begin
    FLast.Next := TItem.Create;
    FLast.Next.Prev := FLast;
    FLast := FLast.Next;
    FLast.Data := AElement;
  end;
  FCount := FCount + 1;
end;

procedure TObjectList.Del(AElement: TObject);
begin
  Del(Find(AElement));
end;

procedure TObjectList.WithEach(AFunc: TWithEachProcedure; AFreeFunction: Boolean);
begin
  with Iterate do while Iterating do
  begin
    AFunc.WithEach(Current);
    Next;
  end;
  if AFreeFunction then
    AFunc.Free;
end;

procedure TObjectList.WithEach(AFunc: TWithEachProcedureBasic);
begin
  with Iterate do while Iterating do
  begin
    AFunc(Current);
    Next;
  end;
end;

function TObjectList.FindFirst(AFunc: TFindFunction; AFreeFunction: Boolean): TObject;
begin
  with Iterate do while Iterating do
  begin
    if AFunc.Find(Current) then
    begin
      Result := Current;
      Stop;
    end;
    Next;
  end;
  if AFreeFunction then
    AFunc.Free;
end;

function TObjectList.FindLast(AFunc: TFindFunction; AFreeFunction: Boolean): TObject;
begin
  with Iterate(idDescending) do while Iterating do
  begin
    if AFunc.Find(Current) then
    begin
      Result := Current;
      Stop;
    end;
    Next;
  end;
  if AFreeFunction then
    AFunc.Free;
end;

function TObjectList.FindAll(AFunc: TFindFunction; AFreeFunction: Boolean): TObjectList;
begin
  Result := TObjectList.Create(True);
  with Iterate do while Iterating do
  begin
    if AFunc.Find(Current) then
      Result.Add(Current);
    Next;
  end;
  if AFreeFunction then
    AFunc.Free;
end;

procedure TObjectList.Sort(AFunc: TCompareFunction);
begin

end;

function TObjectList.Iterate(AIteratorDirection: TIterateDirection): TIterator;
begin
  Result := TIterator.Create(Self, AIteratorDirection);
end;

end.

