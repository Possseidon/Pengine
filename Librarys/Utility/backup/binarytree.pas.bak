unit BinaryTree;

{$IFDEF FPC}
{$mode Delphi}
{$ENDIF}

interface

uses
  Classes, SysUtils;

type

  { TBinaryTreeSorter }

  TBinaryTreeSorter = class abstract
  protected type
    TNode = record
      Left, Right: ^TNode;
      Data: TObject;
    end;
    PNode = ^TNode;

  private
    FRoot: PNode;

    procedure AddToNode(var Node: PNode; Entry: TObject);
    procedure SortedExecuteNode(Node: PNode);

    procedure FreeNode(var Node: PNode);

  protected
    class function Compare(A, B: TObject): Boolean; virtual; abstract;
    class procedure ExecuteEntry(Entry: TObject); virtual; abstract;

  public
    constructor Create;
    destructor Destroy; override;

    procedure AddToTree(Entry: TObject);

    procedure SortedExecute;
  end;

implementation

{ TBinaryTreeSorter }

procedure TBinaryTreeSorter.AddToNode(var Node: PNode; Entry: TObject);
begin
  if Node = nil then
  begin
    Node := AllocMem(SizeOf(TNode));
    Node^.Data := Entry;
  end
  else
  begin
    if Compare(Entry, Node^.Data) then
      AddToNode(Node.Right, Entry)
    else
      AddToNode(Node.Left, Entry);
  end;
end;

procedure TBinaryTreeSorter.SortedExecuteNode(Node: PNode);
begin
  if Node.Left <> nil then
    SortedExecuteNode(Node.Left);
  ExecuteEntry(Node^.Data);
  if Node.Right <> nil then
    SortedExecuteNode(Node.Right);
end;

procedure TBinaryTreeSorter.FreeNode(var Node: PNode);
begin
  if Node.Left <> nil then
    FreeNode(Node.Left);
  if Node.Right <> nil then
    FreeNode(Node.Right);
  //FreeMem(Node);
end;

constructor TBinaryTreeSorter.Create;
begin
  FRoot := AllocMem(SizeOf(TNode));
end;

destructor TBinaryTreeSorter.Destroy;
begin
  FreeNode(FRoot);
  inherited Destroy;
end;

procedure TBinaryTreeSorter.AddToTree(Entry: TObject);
begin
  if FRoot.Data = nil then
    FRoot.Data := Entry
  else
    AddToNode(FRoot, Entry);
end;

procedure TBinaryTreeSorter.SortedExecute;
begin
  SortedExecuteNode(FRoot);
end;

end.

