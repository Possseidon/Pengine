unit ListsBACKUP;

interface

uses
  Classes, SysUtils, Sorting;

type

  TWithEachProcedureBasic = procedure (AElement: TObject) of object;

  TWithEachProcedure = class abstract
  protected
    procedure WithEach(AElement: TObject); virtual; abstract;
  end;

  TFindFunction = class abstract
  protected
    function Find(AElement: TObject): Boolean; virtual; abstract;
  end;

  TCompareFunction = class abstract
  protected
    function Compare(A, B: TObject): Boolean; virtual; abstract;
  end;

  TIterateDirection = (idAscending, idDescending);

  { TObjectList }

  TObjectList = class
  private
    type
      TItem = class
      public
        Data: TObject;
        Next, Prev: TItem;
      end;

  private
    FFirst: TItem;
    FLast: TItem;
    FReferenceList: Boolean;
    FCount: Integer;

    function Find(AElement: TObject): TItem;
    procedure Del(AItem: TItem); overload;
    function GetItem(I: Integer): TObject;
  private
    type

      { TIterator }

      TIterator = class
      private
        FCurrent: TItem;
        FNext: TItem; // if current gets deleted, current.[next/prev] won't exist anymore
        FDirection: TIterateDirection;
        FDoFree: Boolean;
        function GetCurrent: TObject;
      public
        constructor Create(AList: TObjectList; AIterateDirection: TIterateDirection; ADoFree: Boolean);

        function MoveNext: Boolean;
        property Current: TObject read GetCurrent;
        procedure Stop;
      end;
  public
    constructor Create(AReferenceList: Boolean = False);
    destructor Destroy; override;

    procedure Add(AElement: TObject);
    procedure Del(AElement: TObject); overload;
    procedure DelAll;

    procedure WithEach(AFunc: TWithEachProcedure; AFreeFunction: Boolean = True); overload;
    procedure WithEach(AFunc: TWithEachProcedureBasic); overload;
    function FindFirst(AFunc: TFindFunction; AFreeFunction: Boolean = True): TObject;
    function FindLast(AFunc: TFindFunction; AFreeFunction: Boolean = True): TObject;
    function FindAll(AFunc: TFindFunction; AFreeFunction: Boolean = True): TObjectList;

    // procedure Sort(AFunc: TCompareFunction); // No index > Quicksort very slow, mabye tree sort

    function Copy: TObjectList;

    function Iterate(AIteratorDirection: TIterateDirection = idAscending): TIterator;
    function GetEnumerator: TIterator;

    property Item[I: Integer]: TObject read GetItem; default;

    property Count: Integer read FCount;
  end;

  { TObjectArray }

  TObjectArray = class
  private
    FItems: array of TObject;
    FReferenceList: Boolean;

    function GetCount: Integer;
    function GetItem(I: Integer): TObject;

    procedure RangeCheck(AIndex: Integer);

  private
    type

      { TIterator }

      TIterator = class
      private
        FList: TObjectArray;
        FCurrent: Integer;
        function GetCurrent: TObject;
      public
        constructor Create(AList: TObjectArray);

        function MoveNext: Boolean;
        property Current: TObject read GetCurrent;
      end;
    procedure SetItem(I: Integer; AValue: TObject);
  public
    constructor Create(AReferenceList: Boolean = False);
    destructor Destroy; override;

    procedure Add(AElement: TObject);
    procedure DelLast;
    procedure DelAll;

    procedure Insert(AElement: TObject; AIndex: Integer);
    procedure Del(AElement: TObject); overload;
    procedure Del(AIndex: Integer); overload;

    procedure WithEach(AFunc: TWithEachProcedure; AFreeFunction: Boolean = True); overload;
    procedure WithEach(AFunc: TWithEachProcedureBasic); overload;
    function FindFirstIndex(AFunc: TFindFunction; AFreeFunction: Boolean = True): Integer;
    function FindLastIndex(AFunc: TFindFunction; AFreeFunction: Boolean = True): Integer;

    function FindFirst(AFunc: TFindFunction; AFreeFunction: Boolean = True): TObject;
    function FindLast(AFunc: TFindFunction; AFreeFunction: Boolean = True): TObject;

    function FindAsList(AFunc: TFindFunction; AFreeFunction: Boolean = True): TObjectList;
    function FindAsArray(AFunc: TFindFunction; AFreeFunction: Boolean = True): TObjectArray;

    function Copy: TObjectArray;

    procedure Sort(AFunc: TCompareFunction; AFreeFunction: Boolean = True);

    function Find(AElement: TObject): Integer;

    property Count: Integer read GetCount;
    property Item[I: Integer]: TObject read GetItem write SetItem; default;

    function GetEnumerator: TIterator;
  end;

  { TObjectStack }

  TObjectStack = class
  private
    FItems: array of TObject;
    FCount: Integer;
    FReferenceList: Boolean;
    function GetCount: Integer;
  public
    constructor Create(AReferenceList: Boolean = False);
    destructor Destroy; override;

    procedure Push(AElement: TObject);
    function Pop: TObject;
    function Top: TObject;

    function Copy: TObjectStack;
  end;

  { TObjectHashTable }

  TObjectHashTable = class
  private
    type

      { THashEntry }

      THashEntry = class
        Key, Data: TObject;
        Next: THashEntry;
      end;

  private
    FData: array of THashEntry;
    FReferenceList: Boolean;
    FInternalSize: Cardinal;

    function GetEntry(Key: TObject): TObject;
    procedure SetEntry(Key: TObject; AValue: TObject);

  public
    constructor Create(AReferenceList: Boolean = False; AInternalSize: Cardinal = 256);
    destructor Destroy; override;

    property Data[Key: TObject]: TObject read GetEntry write SetEntry; default;
  end;

  { TStringHashTable }

  TStringHashTable = class
  public
    type
      TPair = record
        Key: String;
        Data: TObject;
      end;
  private
    type

      { THashEntry }

      THashEntry = class
        Key: String;
        Data: TObject;
        Next: THashEntry;
      end;

      { TIterator }

      TIterator = class
      private
        FList: TStringHashTable;
        FIndex: Integer;
        FEntry: THashEntry;
        function GetCurrent: TPair;
      public
        constructor Create(AList: TStringHashTable);

        function MoveNext: Boolean;
        property Current: TPair read GetCurrent;
      end;

  private
    FData: array of THashEntry;
    FReferenceList: Boolean;
    FInternalSize: Cardinal;
    FCount: Cardinal;

    function GetEntry(Key: String): TObject;
    function GetNext(Key: String): TObject;
    procedure SetEntry(Key: String; AValue: TObject);

  public
    constructor Create(AReferenceList: Boolean = False; AInternalSize: Cardinal = 256);
    destructor Destroy; override;

    property Data[Key: String]: TObject read GetEntry write SetEntry; default;
    property Next[Key: String]: TObject read GetNext;

    function GetEnumerator: TIterator;
    property Count: Cardinal read FCount;
  end;

  { TArraySorter }

  TArraySorter = class (TQuickSorter)
  private
    FCompareFunction: TCompareFunction;
  protected
    function Compare(A, B: TObject): Boolean; override;
  public
    constructor Create(ACompareFunction: TCompareFunction);
  end;

  function GetHash(AObject: TObject; ARange: Cardinal): Cardinal; overload; inline;
  function GetHash(AString: String; ARange: Cardinal): Cardinal; overload; inline;


implementation

function GetHash(AObject: TObject; ARange: Cardinal): Cardinal;
var
  I: UInt64;
begin
  I := Cardinal(Pointer(AObject));
  Result := (I xor (I shl 3) xor (I shr 7)) mod ARange;
end;

function GetHash(AString: String; ARange: Cardinal): Cardinal;
var
  C: Char;
begin
  Result := 0;
  for C in AString do
    Result := (Result shl 3) xor (Ord(C) xor (Ord(C) shl 3));
  Result := Result mod ARange;
end;

{ TStringHashTable.TIterator }

function TStringHashTable.TIterator.GetCurrent: TPair;
begin
  Result.Key := FEntry.Key;
  Result.Data := FEntry.Data;
end;

constructor TStringHashTable.TIterator.Create(AList: TStringHashTable);
begin
  FList := AList;
  FIndex := -1;
  FEntry := nil;
end;

function TStringHashTable.TIterator.MoveNext: Boolean;
begin
  if (FIndex = -1) or (FEntry.Next = nil) then
  begin
    // Move to next list
    repeat
      FIndex := FIndex + 1;
      if Int64(FIndex) = FList.FInternalSize then
        Exit(False);
      FEntry := FList.FData[FIndex];
    until (FEntry <> nil);
  end
  else
  begin
    FEntry := FEntry.Next;
  end;
  Result := True;
end;

{ TStringHashTable }

function TStringHashTable.GetEntry(Key: String): TObject;
var
  Entry: THashEntry;
  Hash: Cardinal;
begin
  Hash := GetHash(Key, FInternalSize);
  if FData[Hash] = nil then // base entry doesn't exist yet > not found
    Exit(nil);

  Entry := FData[Hash];
  while Entry.Key <> Key do
  begin
    if Entry.Next = nil then // end reached > not found
      Exit(nil);
    Entry := Entry.Next;
  end;
  // found
  Result := Entry.Data;
end;

function TStringHashTable.GetNext(Key: String): TObject;
var
  Hash: Cardinal;
begin
  Hash := GetHash(Key, FInternalSize);
  if FData[Hash].Next <> nil then
    Exit(FData[Hash].Next.Data);
  repeat
    Inc(Hash);
  until (Hash = FInternalSize) or (FData[Hash] <> nil);
  if Hash = FInternalSize then
    Exit(nil);
  Result := FData[Hash].Data;
end;

procedure TStringHashTable.SetEntry(Key: String; AValue: TObject);
var
  Entry, PrevEntry: THashEntry;
  Hash: Cardinal;
begin
  Hash := GetHash(Key, FInternalSize);
  if FData[Hash] = nil then
  begin
    // create new base entry
    FData[Hash] := THashEntry.Create;
    FData[Hash].Key := Key;
    FData[Hash].Data := AValue;
    Inc(FCount);
    Exit;
  end;

  Entry := FData[Hash];
  PrevEntry := nil;
  // find key in list
  while Entry.Key <> Key do
  begin
    if Entry.Next = nil then // not fount > add entry
    begin
      Entry.Next := THashEntry.Create;
      Entry.Next.Key := Key;
      Entry.Next.Data := AValue;
      Inc(FCount);
      Exit;
    end;
    PrevEntry := Entry;
    Entry := Entry.Next;
  end;
  if AValue = nil then // delete entry
  begin
    if Entry.Data = nil then // already nil
      Exit;

    if not FReferenceList then
      Entry.Data.Free;
    if PrevEntry <> nil then
      PrevEntry.Next := Entry.Next
    else
      FData[Hash] := Entry.Next;

    Entry.Free;
    Dec(FCount);
  end
  else // change entry
    Entry.Data := AValue;
end;

constructor TStringHashTable.Create(AReferenceList: Boolean; AInternalSize: Cardinal);
begin
  if AInternalSize = 0 then
    raise Exception.Create('Listsize must be greater than zero!'); // TODO: exception
  SetLength(FData, AInternalSize);
  FInternalSize := AInternalSize;
  FReferenceList := AReferenceList;
end;

destructor TStringHashTable.Destroy;
var
  Next: THashEntry;
  I: Integer;
begin
  for I := 0 to FInternalSize - 1 do
  begin
    if FData[I] = nil then
      Continue;
    repeat
      Next := FData[I].Next;
      if not FReferenceList then
        FData[I].Data.Free;
      FData[I].Free;
      FData[I] := Next;
    until Next = nil;
  end;
  inherited Destroy;
end;

function TStringHashTable.GetEnumerator: TIterator;
begin
  Result := TIterator.Create(Self);
end;

{ TObjectHashTable }

function TObjectHashTable.GetEntry(Key: TObject): TObject;
var
  Entry: THashEntry;
  Hash: Cardinal;
begin
  Hash := GetHash(Key, FInternalSize);
  if FData[Hash] = nil then // base entry doesn't exist yet > not found
    Exit(nil);

  Entry := FData[Hash];
  while Pointer(Entry.Key) <> Pointer(Key) do
  begin
    if Entry.Next = nil then // end reached > not found
      Exit(nil);
    Entry := Entry.Next;
  end;
  // found
  Result := Entry.Data;
end;

procedure TObjectHashTable.SetEntry(Key: TObject; AValue: TObject);
var
  Entry, PrevEntry: THashEntry;
  Hash: Cardinal;
begin
  Hash := GetHash(Key, FInternalSize);
  if FData[Hash] = nil then
  begin
    // create new base entry
    FData[Hash] := THashEntry.Create;
    FData[Hash].Key := Key;
    FData[Hash].Data := AValue;
    Exit;
  end;

  Entry := FData[Hash];
  PrevEntry := nil;
  // find key in list
  while Pointer(Entry.Key) <> Pointer(Key) do
  begin
    if Entry.Next = nil then // not fount > add entry
    begin
      Entry.Next := THashEntry.Create;
      Entry.Next.Key := Key;
      Entry.Next.Data := AValue;
      Exit;
    end;
    PrevEntry := Entry;
    Entry := Entry.Next;
  end;
  if AValue = nil then // delete entry
  begin
    if Entry.Data = nil then // already nil
      Exit;

    if not FReferenceList then
      Entry.Data.Free;
    if PrevEntry <> nil then
      PrevEntry.Next := Entry.Next
    else
      FData[Hash] := Entry.Next;

    Entry.Free;
  end
  else // change entry
    Entry.Data := AValue;
end;

constructor TObjectHashTable.Create(AReferenceList: Boolean; AInternalSize: Cardinal);
begin
  if AInternalSize = 0 then
    raise Exception.Create('Listsize must be greater than zero!'); // TODO: exception
  SetLength(FData, AInternalSize);
  FInternalSize := AInternalSize;
  FReferenceList := AReferenceList;
end;

destructor TObjectHashTable.Destroy;
var
  Next: THashEntry;
  I: Integer;
begin
  for I := 0 to FInternalSize - 1 do
  begin
    if FData[I] = nil then
      Continue;
    repeat
      Next := FData[I].Next;
      if not FReferenceList then
        FData[I].Data.Free;
      FData[I].Free;
      FData[I] := Next;
    until Next = nil;
  end;
  inherited Destroy;
end;

{ TObjectStack }

function TObjectStack.GetCount: Integer;
begin
  Result := FCount;
end;

constructor TObjectStack.Create(AReferenceList: Boolean);
begin
  FReferenceList := AReferenceList;
end;

destructor TObjectStack.Destroy;
begin
  if not FReferenceList then
    while FCount > 0 do
      Pop.Free;
  inherited Destroy;
end;

procedure TObjectStack.Push(AElement: TObject);
begin
  SetLength(FItems, Length(FItems) + 1);
  FItems[Length(FItems) - 1] := AElement;
  Inc(FCount);
end;

function TObjectStack.Pop: TObject;
begin
  if FCount = 0 then
    Exit(nil);
  Dec(FCount);
  Result := FItems[FCount]; // "count - 1" but already decremented
  SetLength(FItems, FCount);
end;

function TObjectStack.Top: TObject;
begin
  Result := FItems[FCount - 1];
end;

function TObjectStack.Copy: TObjectStack;
var
  I: Integer;
begin
  Result := TObjectStack.Create;
  for I := 0 to FCount - 1 do
    Result.Push(FItems[I]);
end;

{ TObjectArray.TIterator }

function TObjectArray.TIterator.GetCurrent: TObject;
begin
  Result := FList[FCurrent];
end;

constructor TObjectArray.TIterator.Create(AList: TObjectArray);
begin
  FList := AList;
  FCurrent := -1;
end;

function TObjectArray.TIterator.MoveNext: Boolean;
begin
  Inc(FCurrent);
  Result := FCurrent <> FList.Count;
end;

{ TArraySorter }

constructor TArraySorter.Create(ACompareFunction: TCompareFunction);
begin
  FCompareFunction := ACompareFunction;
end;

function TArraySorter.Compare(A, B: TObject): Boolean;
begin
  Result := FCompareFunction.Compare(A, B);
end;

{ TObjectArray }

function TObjectArray.GetItem(I: Integer): TObject;
begin
  RangeCheck(I);
  Result := FItems[I];
end;

procedure TObjectArray.RangeCheck(AIndex: Integer);
begin
  if (AIndex >= Count) or (AIndex < 0) then
    raise Exception.Create(Format('Item out of bounds! (%d >= %d)', [AIndex, Count])); // TODO: ObjectArray Get Item Exception
end;

procedure TObjectArray.SetItem(I: Integer; AValue: TObject);
begin
  RangeCheck(I);
  if not FReferenceList then
    FItems[I].Free;
  FItems[I] := AValue;
end;

constructor TObjectArray.Create(AReferenceList: Boolean);
begin
  FReferenceList := AReferenceList;
end;

destructor TObjectArray.Destroy;
var
  I: Integer;
begin
  if not FReferenceList then
    for I := 0 to Count - 1 do with FItems[I] do
      Free;
  inherited;
end;

procedure TObjectArray.Add(AElement: TObject);
begin
  SetLength(FItems, Count + 1);
  FItems[Count - 1] := AElement;
end;

procedure TObjectArray.DelLast;
begin
  if not FReferenceList then
    FItems[Count - 1].Free;
  SetLength(FItems, Count - 1);
end;

procedure TObjectArray.DelAll;
var
  I: Integer;
begin
  if not FReferenceList then
    for I := 0 to Count - 1 do
      FItems[I].Free;
  SetLength(FItems, 0);
end;

procedure TObjectArray.Insert(AElement: TObject; AIndex: Integer);
begin
  SetLength(FItems, Count + 1);
  Move(FItems[AIndex], FItems[AIndex + 1], SizeOf(FItems[AIndex]) * (Count - AIndex));
  FItems[AIndex] := AElement;
end;

procedure TObjectArray.Del(AElement: TObject);
begin
  Del(Find(AElement));
end;

procedure TObjectArray.Del(AIndex: Integer);
begin
  if not FReferenceList then
    FItems[AIndex].Free;
  if Count - AIndex - 1 > 0 then
    Move(FItems[AIndex + 1], FItems[AIndex], SizeOf(FItems[AIndex]) * (Count - AIndex - 1));
  SetLength(FItems, Count - 1);
end;

procedure TObjectArray.WithEach(AFunc: TWithEachProcedure; AFreeFunction: Boolean);
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    AFunc.WithEach(FItems[I]);
  if AFreeFunction then
    AFunc.Free;
end;

procedure TObjectArray.WithEach(AFunc: TWithEachProcedureBasic);
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
    AFunc(FItems[I]);
end;

function TObjectArray.FindFirstIndex(AFunc: TFindFunction; AFreeFunction: Boolean): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := 0 to Count - 1 do
    if AFunc.Find(FItems[I]) then
    begin
      Result := I;
      Break;
    end;
  if AFreeFunction then
    AFunc.Free;
end;

function TObjectArray.FindLastIndex(AFunc: TFindFunction; AFreeFunction: Boolean): Integer;
var
  I: Integer;
begin
  Result := -1;
  for I := Count - 1 downto 0 do
    if AFunc.Find(FItems[I]) then
    begin
      Result := I;
      Break;
    end;
  if AFreeFunction then
    AFunc.Free;
end;

function TObjectArray.FindFirst(AFunc: TFindFunction; AFreeFunction: Boolean): TObject;
var
  I: Integer;
begin
  I := FindFirstIndex(AFunc, AFreeFunction);
  if I = -1 then
    Result := nil
  else
    Result := FItems[I];
end;

function TObjectArray.FindLast(AFunc: TFindFunction; AFreeFunction: Boolean): TObject;
var
  I: Integer;
begin
  I := FindLastIndex(AFunc, AFreeFunction);
  if I = -1 then
    Result := nil
  else
    Result := FItems[I];
end;

function TObjectArray.FindAsList(AFunc: TFindFunction; AFreeFunction: Boolean): TObjectList;
var
  I: Integer;
begin
  Result := TObjectList.Create(True);
  for I := 0 to Count - 1 do
    if AFunc.Find(FItems[I]) then
      Result.Add(FItems[I]);
  if AFreeFunction then
    AFunc.Free;
end;

function TObjectArray.FindAsArray(AFunc: TFindFunction; AFreeFunction: Boolean): TObjectArray;
var
  I: Integer;
begin
  Result := TObjectArray.Create(True);
  for I := 0 to Count - 1 do
    if AFunc.Find(FItems[I]) then
      Result.Add(FItems[I]);
  if AFreeFunction then
    AFunc.Free;
end;

function TObjectArray.Find(AElement: TObject): Integer;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do with FItems[I] do
    if Pointer(AElement) = Pointer(FItems[I]) then
      Exit(I);
end;

function TObjectArray.GetEnumerator: TIterator;
begin
  Result := TIterator.Create(Self);
end;

function TObjectArray.Copy: TObjectArray;
var
  I: Integer;
begin
  Result := TObjectArray.Create(True);
  for I := 0 to Count - 1 do
    Result.Add(FItems[I]);
end;

procedure TObjectArray.Sort(AFunc: TCompareFunction; AFreeFunction: Boolean);
var
  QS: TQuickSorter;
begin
  QS := TArraySorter.Create(AFunc);
  QS.Sort(FItems);
  if AFreeFunction then
    AFunc.Free;
end;

function TObjectArray.GetCount: Integer;
begin
  Result := Length(FItems);
end;

{ TObjectList.TIterator }

constructor TObjectList.TIterator.Create(AList: TObjectList; AIterateDirection: TIterateDirection; ADoFree: Boolean);
begin
  FDirection := AIterateDirection;
  case FDirection of
    idAscending:
      FNext := AList.FFirst;
    idDescending:
      FNext := AList.FLast;
  end;
  FDoFree := ADoFree;
end;

function TObjectList.TIterator.MoveNext: Boolean;
begin
  Result := FNext <> nil;
  if Result then
  begin
    FCurrent := FNext;
    case FDirection of
      idAscending:
        FNext := FNext.Next;
      idDescending:
        FNext := FNext.Prev;
    end;
  end
  else if FDoFree then
    Free;
end;

function TObjectList.TIterator.GetCurrent: TObject;
begin
  if FCurrent <> nil then
    Result := FCurrent.Data
  else
    Result := nil;
end;

procedure TObjectList.TIterator.Stop;
begin
  FNext := nil;
end;

{ TObjectList }

function TObjectList.Find(AElement: TObject): TItem;
var
  I: TItem;
begin
  I := FFirst;
  while (I <> nil) and (Pointer(I.Data) <> Pointer(AElement)) do
    I := I.Next;
  if I = nil then
    raise Exception.Create('TODO! Could not find Element in List');
  Result := I;
end;

procedure TObjectList.Del(AItem: TItem);
begin
  with AItem do
  begin
    if Prev = nil then
      FFirst := Next
    else
      Prev.Next := Next;
    if Next = nil then
      FLast := Prev
    else
      Next.Prev := Prev;

    if not FReferenceList then
      Data.Free;
    Free;
  end;
  FCount := FCount - 1;
end;

function TObjectList.GetItem(I: Integer): TObject;
var
  FPos: TItem;
begin
  if (I >= Count) or (I < 0) then
    raise Exception.Create('Item out of bounds'); // TODO: ObjectList Get Item Exception
  FPos := FFirst;
  while I > 0 do
  begin
    FPos := FPos.Next;
    Dec(I);
  end;
  Result := FPos.Data;
end;

constructor TObjectList.Create(AReferenceList: Boolean);
begin
  FReferenceList := AReferenceList;
end;

destructor TObjectList.Destroy;
begin
  DelAll;
  inherited Destroy;
end;

procedure TObjectList.Add(AElement: TObject);
begin
  if FLast = nil then
  begin
    FFirst := TItem.Create;
    FLast := FFirst;
    FFirst.Data := AElement;
  end
  else
  begin
    FLast.Next := TItem.Create;
    FLast.Next.Prev := FLast;
    FLast := FLast.Next;
    FLast.Data := AElement;
  end;
  FCount := FCount + 1;
end;

procedure TObjectList.Del(AElement: TObject);
begin
  Del(Find(AElement));
end;

procedure TObjectList.DelAll;
begin
  while FCount > 0 do
    Del(FLast);
end;

procedure TObjectList.WithEach(AFunc: TWithEachProcedure; AFreeFunction: Boolean);
var
  Current: TObject;
begin
  for Current in Self do
    AFunc.WithEach(Current);
  if AFreeFunction then
    AFunc.Free;
end;

procedure TObjectList.WithEach(AFunc: TWithEachProcedureBasic);
var
  Current: TObject;
begin
  for Current in Self do
    AFunc(Current);
end;

function TObjectList.FindFirst(AFunc: TFindFunction; AFreeFunction: Boolean): TObject;
var
  Current: TObject;
begin
  for Current in Self do
    if AFunc.Find(Current) then
    begin
      Result := Current;
      Break;
    end;
  if AFreeFunction then
    AFunc.Free;
end;

function TObjectList.FindLast(AFunc: TFindFunction; AFreeFunction: Boolean): TObject;
begin
  with Iterate(idDescending) do while MoveNext do
    if AFunc.Find(Current) then
    begin
      Result := Current;
      Stop;
    end;
  if AFreeFunction then
    AFunc.Free;
end;

function TObjectList.FindAll(AFunc: TFindFunction; AFreeFunction: Boolean): TObjectList;
var
  Current: TObject;
begin
  Result := TObjectList.Create(True);
  for Current in Self do
    if AFunc.Find(Current) then
      Result.Add(Current);
  if AFreeFunction then
    AFunc.Free;
end;

function TObjectList.Copy: TObjectList;
var
  Current: TObject;
begin
  Result := TObjectList.Create(True);
  for Current in Self do
    Result.Add(Current);
end;

function TObjectList.Iterate(AIteratorDirection: TIterateDirection): TIterator;
begin
  Result := TIterator.Create(Self, AIteratorDirection, True);
end;

function TObjectList.GetEnumerator: TIterator;
begin
  Result := TIterator.Create(Self, idAscending, False);
end;

end.

